{"version":3,"file":"build/polymer.js","sources":["src/polymer.js","src/boot.js","src/lib/lang.js","src/lib/job.js","src/lib/dom.js","src/lib/super.js","src/lib/deserialize.js","src/api.js","src/instance/utils.js","src/instance/events.js","src/instance/attributes.js","src/instance/properties.js","src/instance/mdv.js","src/instance/base.js","src/instance/styles.js","src/declaration/path.js","src/declaration/styles.js","src/declaration/events.js","src/declaration/properties.js","src/declaration/attributes.js","src/declaration/prototype.js","src/declaration/queue.js","src/declaration/polymer-element.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAKA,WCKA,kBAAA,QAAA,UACA,YCNA,SAAA,GAGA,QAAA,GAAA,EAAA,GAiBA,MAhBA,IAAA,GAEA,OAAA,oBAAA,GAAA,QAAA,SAAA,GAEA,GAAA,GAAA,OAAA,yBAAA,EAAA,EACA,KAEA,OAAA,eAAA,EAAA,EAAA,GAEA,kBAAA,GAAA,QAEA,EAAA,MAAA,IAAA,MAKA,EAKA,EAAA,OAAA,GAEA,SC1BA,SAAA,GA6CA,QAAA,GAAA,EAAA,EAAA,GAOA,MANA,GACA,EAAA,OAEA,EAAA,GAAA,GAAA,MAEA,EAAA,GAAA,EAAA,GACA,EAzCA,GAAA,GAAA,SAAA,GACA,KAAA,QAAA,EACA,KAAA,cAAA,KAAA,SAAA,KAAA,MAEA,GAAA,WACA,GAAA,SAAA,EAAA,GACA,KAAA,SAAA,CACA,IAAA,EACA,IAMA,EAAA,WAAA,KAAA,cAAA,GACA,KAAA,OAAA,WACA,aAAA,MAPA,EAAA,sBAAA,KAAA,eACA,KAAA,OAAA,WACA,qBAAA,MASA,KAAA,WACA,KAAA,SACA,KAAA,SACA,KAAA,OAAA,OAGA,SAAA,WACA,KAAA,SACA,KAAA,OACA,KAAA,SAAA,KAAA,KAAA,YAiBA,EAAA,IAAA,GAEA,SC5DA,WAEA,GAAA,KAEA,aAAA,SAAA,SAAA,EAAA,GACA,EAAA,GAAA,GAIA,YAAA,mBAAA,SAAA,GACA,GAAA,GAAA,EAAA,EAAA,GAAA,YAAA,SAEA,OAAA,IAAA,OAAA,eAAA,SAAA,cAAA,IAIA,IAAA,GAAA,MAAA,UAAA,eACA,OAAA,UAAA,gBAAA,WACA,KAAA,cAAA,EACA,EAAA,MAAA,KAAA,aASA,SC5BA,SAAA,GAgBA,QAAA,GAAA,GAMA,GAAA,GAAA,EAAA,OAEA,EAAA,EAAA,IAEA,EAAA,EAAA,MAYA,IAXA,IACA,IACA,EAAA,EAAA,IAAA,EAAA,KAAA,KAAA,IAEA,GACA,QAAA,KAAA,iFAIA,EAAA,EAAA,EAAA,EAAA,EAAA,QAEA,EAGA,CAEA,GAAA,GAAA,EAAA,EAOA,OALA,GAAA,QACA,EAAA,EAAA,EAAA,GAIA,EAAA,MAAA,KAAA,QAIA,QAAA,GAAA,EAAA,EAAA,GAEA,KAAA,GAAA,CACA,GAAA,EAAA,KAAA,GAAA,EAAA,GACA,MAAA,EAEA,GAAA,EAAA,IAIA,QAAA,GAAA,EAAA,EAAA,GAUA,MANA,GAAA,OAAA,EAAA,EAAA,EAAA,GACA,EAAA,SAGA,EAAA,OAAA,GAAA,IAAA,GAEA,EAAA,OAGA,QAAA,GAAA,GAEA,IADA,GAAA,GAAA,KAAA,UACA,GAAA,IAAA,YAAA,WAAA,CAGA,IAAA,GAAA,GADA,EAAA,OAAA,oBAAA,GACA,EAAA,EAAA,EAAA,EAAA,OAAA,EAAA,IAAA,EAAA,EAAA,IAAA,IAAA,CACA,GAAA,GAAA,OAAA,yBAAA,EAAA,EACA,IAAA,kBAAA,GAAA,OAAA,EAAA,QAAA,EACA,MAAA,GAGA,EAAA,EAAA,WAOA,QAAA,GAAA,GACA,MAAA,GAAA,UAkBA,EAAA,MAAA,GAEA,SCnHA,SAAA,GA8CA,QAAA,GAAA,EAAA,GAEA,GAAA,SAAA,EAMA,OAJA,aAAA,QACA,EAAA,QAGA,EAAA,GAAA,EAAA,GApDA,GAAA,IACA,OAAA,SAAA,GACA,MAAA,IAEA,KAAA,SAAA,GACA,MAAA,IAAA,MAAA,KAAA,MAAA,IAAA,KAAA,QAEA,UAAA,SAAA,GACA,MAAA,KAAA,GACA,EAEA,UAAA,GAAA,IAAA,GAEA,OAAA,SAAA,GACA,GAAA,GAAA,WAAA,EAKA,OAHA,KAAA,IACA,EAAA,SAAA,IAEA,MAAA,GAAA,EAAA,GAKA,OAAA,SAAA,EAAA,GACA,GAAA,OAAA,EACA,MAAA,EAEA,KAIA,MAAA,MAAA,MAAA,EAAA,QAAA,KAAA,MACA,MAAA,GAEA,MAAA,KAIA,WAAA,SAAA,EAAA,GACA,MAAA,IAiBA,GAAA,iBAAA,GAEA,SC9DA,SAAA,GAEA,GAAA,KAEA,GAAA,eACA,EAAA,YAIA,EAAA,IAAA,GAEA,SCXA,SAAA,GAEA,GAAA,IASA,MAAA,SAAA,EAAA,EAAA,GAGA,SAAA,QAEA,EAAA,GAAA,EAAA,OAAA,GAAA,EAEA,IAAA,GAAA,YACA,KAAA,IAAA,GAAA,MAAA,KAAA,IACA,KAAA,KAEA,OAAA,GAAA,WAAA,EAAA,GAAA,sBAAA,IAUA,KAAA,SAAA,EAAA,EAAA,EAAA,EAAA,GACA,GAAA,GAAA,GAAA,KACA,EAAA,MACA,EAAA,GAAA,aAAA,GACA,QAAA,SAAA,EAAA,GAAA,EACA,WAAA,SAAA,EAAA,GAAA,EACA,OAAA,GAGA,OADA,GAAA,cAAA,GACA,GASA,UAAA,WACA,KAAA,MAAA,OAAA,YASA,aAAA,SAAA,EAAA,EAAA,GACA,GACA,EAAA,UAAA,OAAA,GAEA,GACA,EAAA,UAAA,IAAA,KAMA,EAAA,aAEA,IAIA,GAAA,YAAA,EAAA,MAIA,EAAA,IAAA,SAAA,MAAA,EACA,EAAA,IAAA,EACA,EAAA,IAAA,GAEA,SCpFA,SAAA,GAkHA,QAAA,GAAA,GACA,KAAA,EAAA,YACA,EAAA,EAAA,UAEA,OAAA,GAAA,KAlHA,GAAA,GAAA,OAAA,aAIA,EAAA,MAKA,GAEA,aAAA,EAEA,eAAA,SAAA,GACA,MAAA,IAAA,MAAA,EAAA,IAAA,MAAA,EAAA,IAAA,MAAA,EAAA,IAEA,kBAAA,SAAA,GACA,MAAA,GAAA,MAAA,IAGA,iBAAA,WACA,GAAA,GAAA,KAAA,cACA,GAAA,QAAA,OAAA,KAAA,GAAA,OAAA,GAAA,QAAA,IAAA,yBAAA,KAAA,UAAA,GACA,KAAA,iBAAA,KAAA,EAAA,KAAA,oBAEA,iBAAA,SAAA,EAAA,EAAA,GAGA,GAAA,EACA,KAAA,GAAA,KAAA,GACA,IACA,EAAA,EAAA,KAAA,OAEA,KAAA,gBAAA,EAAA,EAAA,IAGA,gBAAA,SAAA,EAAA,EAAA,GACA,EAAA,iBAAA,EAAA,IAEA,kBAAA,SAAA,GACA,IAAA,EAAA,aAAA,CACA,EAAA,QAAA,QAAA,MAAA,8BAAA,KAAA,UAAA,EAAA,KACA,IAAA,GAAA,KAAA,kBAAA,EACA,KACA,EAAA,QAAA,QAAA,IAAA,oCAAA,KAAA,UAAA,GACA,KAAA,eAAA,KAAA,GAAA,EAAA,EAAA,OAAA,QAEA,EAAA,QAAA,QAAA,aAIA,kBAAA,SAAA,GACA,MAAA,MAAA,eAAA,EAAA,OAGA,eAAA,SAAA,EAAA,EAAA,GACA,GAAA,EAAA,CACA,EAAA,QAAA,QAAA,MAAA,qBAAA,EAAA,UAAA,EACA,IAAA,GAAA,kBAAA,GAAA,EAAA,EAAA,EACA,IACA,EAAA,EAAA,QAAA,QAAA,EAAA,GAEA,EAAA,QAAA,QAAA,WACA,SAAA,UAYA,eAAA,SAAA,EAAA,GAEA,MAAA,GAAA,eAAA,GAEA,SAAA,EAAA,GACA,EAAA,QAAA,QAAA,IAAA,+BAAA,EAAA,UAAA,EAAA,UAAA,EACA,IAAA,GAAA,SAAA,GACA,GAAA,GAAA,EAAA,EACA,IAAA,GAAA,EAAA,eAAA,CACA,GAAA,GAAA,EAAA,EAAA,CACA,MAAA,EAAA,KACA,EAAA,EACA,EAAA,KAAA,IAAA,EAAA,MAAA,IAAA,aAAA,IAEA,EAAA,eAAA,EAAA,GAAA,EAAA,EAAA,OAAA,MAGA,EAAA,EAAA,kBAAA,EACA,QACA,KAAA,WACA,EAAA,iBAAA,EAAA,GAAA,IAEA,MAAA,WACA,EAAA,QAAA,QAAA,IAAA,sCAAA,EAAA,UAAA,EAAA,EAAA,UAAA,GACA,EAAA,oBAAA,EAAA,GAAA,IAEA,eAAA,eAxBA,SA+BA,EAAA,EAAA,MAWA,GAAA,IAAA,SAAA,OAAA,GAEA,SC9HA,SAAA,GAIA,GAAA,IACA,uBAAA,WACA,GAAA,GAAA,KAAA,mBACA,KAAA,GAAA,KAAA,GACA,KAAA,aAAA,IACA,KAAA,aAAA,EAAA,EAAA,KAKA,eAAA,WAGA,GAAA,KAAA,WACA,IAAA,GAAA,GAAA,EAAA,EAAA,EAAA,KAAA,WAAA,EAAA,EAAA,QAAA,EAAA,EAAA,KAAA,EAAA,EAAA,IACA,KAAA,oBAAA,EAAA,KAAA,EAAA,QAMA,oBAAA,SAAA,EAAA,GAGA,GAAA,GAAA,KAAA,qBAAA,EACA,IAAA,EAAA,CAIA,GAAA,GAAA,EAAA,OAAA,EAAA,cAAA,EACA,MAGA,IAAA,GAAA,KAAA,GAEA,EAAA,KAAA,iBAAA,EAAA,EAEA,KAAA,IAEA,KAAA,GAAA,KAKA,qBAAA,SAAA,GACA,GAAA,GAAA,KAAA,YAAA,KAAA,WAAA,EAEA,OAAA,IAGA,iBAAA,SAAA,EAAA,GACA,MAAA,GAAA,iBAAA,EAAA,IAEA,eAAA,SAAA,EAAA,GACA,MAAA,YAAA,EACA,EAAA,GAAA,OACA,WAAA,GAAA,aAAA,GACA,SAAA,EACA,EAFA,QAKA,2BAAA,SAAA,GACA,GAAA,SAAA,MAAA,GAEA,EAAA,KAAA,eAAA,KAAA,GAAA,EAEA,UAAA,EACA,KAAA,aAAA,EAAA,GAMA,YAAA,GACA,KAAA,gBAAA,IAOA,GAAA,IAAA,SAAA,WAAA,GAEA,SCvFA,SAAA,GA0HA,QAAA,GAAA,EAAA,EAAA,GACA,EAAA,MAAA,QAAA,IAAA,EAAA,IAAA,WAAA,SAAA,OAAA,EAAA,UAAA,EAIA,IAAA,GAAA,EAAA,gBAIA,QAHA,OAAA,GAAA,SAAA,IACA,EAAA,SAAA,EAAA,IAEA,SAAA,uBAAA,EAAA,EAAA,GA/HA,GAAA,GAAA,OAAA,aAUA,GACA,kBAAA,WACA,GAAA,GAAA,KAAA,cAAA,EAAA,KAAA,aACA,IAAA,GAAA,EAAA,QAAA,GAAA,EAAA,OAAA,CAGA,IAAA,GAAA,GADA,EAAA,KAAA,kBAAA,GAAA,kBACA,EAAA,EAAA,EAAA,EAAA,OAAA,EAAA,IAAA,EAAA,EAAA,IAAA,IAAA,CACA,EAAA,QAAA,KAAA,EAEA,IAAA,GAAA,OAAA,yBAAA,KAAA,UAAA,EACA,IAAA,EAAA,OACA,KAAA,kBAAA,EAAA,EAAA,MAAA,MAGA,IAAA,GAAA,GAAA,EAAA,EAAA,EAAA,EAAA,OAAA,EAAA,IAAA,EAAA,EAAA,IAAA,IACA,KAAA,SAAA,SAAA,KAAA,QAAA,IACA,EAAA,QAAA,KAAA,EAGA,GAAA,KAAA,KAAA,sBAAA,QAGA,sBAAA,SAAA,EAAA,EAAA,GACA,GAAA,GAAA,EAAA,IACA,KAAA,GAAA,KAAA,GAEA,EAAA,EAAA,EAAA,EAAA,GACA,SAAA,KAAA,QAAA,IACA,KAAA,2BAAA,GAEA,EAAA,KAAA,QAAA,GACA,IACA,KAAA,kBAAA,EAAA,EAAA,GAAA,EAAA,IACA,EAAA,KACA,EAAA,IAAA,EAEA,KAAA,aAAA,GAAA,EAAA,GAAA,EAAA,GAAA,eAKA,kBAAA,SAAA,EAAA,EAAA,GAEA,GAAA,GAAA,KAAA,QAAA,EACA,IAAA,IAEA,MAAA,QAAA,KACA,EAAA,SAAA,QAAA,IAAA,mDAAA,KAAA,UAAA,GACA,KAAA,mBAAA,EAAA,YAGA,MAAA,QAAA,IAAA,CACA,EAAA,SAAA,QAAA,IAAA,iDAAA,KAAA,UAAA,EAAA,EACA,IAAA,GAAA,GAAA,eAAA,EACA,GAAA,KAAA,SAAA,EAAA,GACA,KAAA,aAAA,GAAA,KACA,MACA,KAAA,iBAAA,EAAA,UAAA,KAIA,aAAA,SAAA,EAAA,GAEA,MAAA,GAAA,KAAA,EAAA,IAEA,oBAAA,WACA,KAAA,mBACA,KAAA,kBAAA,QAEA,KAAA,uBAEA,eAAA,SAAA,GACA,MAAA,MAAA,mBAAA,IAEA,aAAA,SAAA,EAAA,GACA,GAAA,GAAA,KAAA,IAAA,CACA,mBAAA,IACA,EAAA,MAAA,KAAA,IAIA,iBAAA,SAAA,EAAA,GACA,GAAA,GAAA,KAAA,aAAA,KAAA,cACA,GAAA,GAAA,GAEA,mBAAA,SAAA,GACA,GAAA,GAAA,KAAA,UACA,OAAA,IAAA,EAAA,IACA,EAAA,GAAA,QACA,EAAA,GAAA,MACA,GAHA,QAMA,oBAAA,WACA,GAAA,KAAA,WAAA,CAEA,IAAA,GAAA,GAAA,EADA,EAAA,OAAA,KAAA,KAAA,YACA,EAAA,EAAA,EAAA,EAAA,OAAA,EAAA,IAAA,EAAA,EAAA,IAAA,IACA,EAAA,KAAA,WAAA,GACA,EAAA,OAEA,MAAA,iBAwBA,EAAA,yCAIA,GAAA,IAAA,SAAA,WAAA,GAEA,SChJA,SAAA,GA6FA,QAAA,GAAA,GACA,EAAA,EAAA,GAGA,QAAA,GAAA,GACA,EAAA,YAGA,QAAA,GAAA,EAAA,GACA,GAAA,EAAA,CACA,EAAA,EACA,KAAA,GAAA,GAAA,EAAA,WAAA,EAAA,EAAA,EAAA,YACA,EAAA,EAAA,IArGA,GAAA,GAAA,OAAA,UAAA,EACA,EAAA,EAAA,IAAA,SAAA,OAMA,EAAA,mBAAA,UAAA,cAEA,oBAAA,UAAA,eAAA,SAAA,EAAA,EAAA,GAEA,MAAA,GAAA,eAAA,EAAA,EAAA,IACA,EAAA,KAAA,KAAA,EAAA,EAAA,GAGA,IAAA,GAAA,GAAA,oBAIA,GACA,OAAA,EACA,iBAAA,SAAA,GACA,MAAA,GAAA,eAAA,KAAA,KAAA,SAEA,KAAA,SAAA,EAAA,GAGA,KAAA,kBACA,KAAA,gBAEA,IAAA,GAAA,KAAA,qBAAA,EACA,IAAA,EAIA,CAEA,KAAA,OAAA,EAEA,IAAA,GAAA,KAAA,aAAA,EAAA,EAOA,OALA,GAAA,KAAA,EAAA,MAIA,KAAA,2BAAA,GACA,KAAA,SAAA,GAAA,EAZA,MAAA,MAAA,WAAA,YAeA,eAAA,WACA,KAAA,WACA,EAAA,QAAA,QAAA,IAAA,sBAAA,KAAA,WACA,KAAA,cAAA,KAAA,IAAA,KAAA,cAAA,KAAA,UAAA,KAGA,UAAA,WACA,IAAA,KAAA,SAAA,CACA,KAAA,sBACA,KAAA,OAGA,KADA,GAAA,GAAA,KAAA,WACA,GACA,EAAA,GACA,EAAA,EAAA,eAEA,MAAA,UAAA,IAGA,gBAAA,SAAA,GACA,MAAA,MAAA,UACA,EAAA,QAAA,QAAA,KAAA,gDAAA,KAAA,WACA,SAEA,EAAA,QAAA,QAAA,IAAA,uBAAA,KAAA,WACA,KAAA,gBACA,KAAA,cAAA,KAAA,cAAA,QAIA,GACA,EAAA,KAAA,WAAA,SAAA,GACA,EAAA,iBACA,EAAA,oBATA,UAiCA,EAAA,gBAIA,GAAA,YAAA,EACA,EAAA,IAAA,SAAA,IAAA,GAEA,SCrHA,SAAA,GAsLA,QAAA,GAAA,GACA,MAAA,GAAA,eAAA,eAKA,QAAA,MA3LA,GAAA,GAAA,EAEA,GACA,aAAA,EACA,IAAA,QAAA,IACA,QAAA,QAAA,MAEA,QAAA,aAIA,MAAA,aAEA,gBAAA,WACA,KAAA,WACA,KAAA,cAAA,aAAA,KAAA,eACA,EAAA,IACA,KAAA,kBAIA,eAAA,WACA,KAAA,kBAAA,EAEA,KAAA,oBAEA,KAAA,yBAEA,KAAA,iBAEA,KAAA,mBAGA,IAEA,KAAA,kBAAA,KAAA,WAEA,IAEA,KAAA,SAEA,iBAAA,WACA,KAAA,kBACA,KAAA,iBAEA,KAAA,iBAAA,GAEA,KAAA,UACA,KAAA,WAGA,KAAA,aACA,KAAA,eAGA,iBAAA,WACA,KAAA,gBACA,KAAA,iBAGA,KAAA,UACA,KAAA,WAGA,KAAA,UACA,KAAA,YAIA,oBAAA,WACA,KAAA,oBAGA,iBAAA,WACA,KAAA,oBAGA,wBAAA,WACA,KAAA,oBAGA,qBAAA,WACA,KAAA,oBAGA,kBAAA,SAAA,GACA,GAAA,EAAA,UACA,KAAA,kBAAA,EAAA,WACA,EAAA,iBAAA,KAAA,KAAA,EAAA,WAIA,iBAAA,SAAA,GACA,GAAA,GAAA,KAAA,cAAA,EACA,KACA,KAAA,QAAA,aAAA,YACA,KAAA,kBAAA,GAEA,KAAA,mBAAA,KAKA,cAAA,SAAA,GACA,MAAA,GAAA,cAAA,aAGA,mBAAA,SAAA,GACA,GAAA,EAAA,CAEA,GAEA,IAFA,KAAA,WAEA,KAAA,mBAEA,GAAA,sBAAA,KAAA,qBAKA,IAAA,GAAA,KAAA,iBAAA,EAMA,OAJA,GAAA,YAAA,GAEA,KAAA,gBAAA,EAAA,GAEA,IAIA,kBAAA,SAAA,GACA,GAAA,EAAA,CAKA,GAAA,GAAA,KAAA,iBAAA,EAMA,OAJA,MAAA,YAAA,GAEA,KAAA,gBAAA,KAAA,GAEA,IAGA,gBAAA,SAAA,GAEA,KAAA,sBAAA,GAEA,gBAAA,SAAA,IAGA,sBAAA,SAAA,GAEA,GAAA,GAAA,KAAA,EAAA,KAAA,KAEA,IAAA,EAEA,IAAA,GAAA,GADA,EAAA,EAAA,iBAAA,QACA,EAAA,EAAA,EAAA,EAAA,OAAA,EAAA,IAAA,EAAA,EAAA,IAAA,IACA,EAAA,EAAA,IAAA,GAIA,yBAAA,SAAA,GAEA,UAAA,GAAA,UAAA,GACA,KAAA,oBAAA,EAAA,KAAA,aAAA,IAEA,KAAA,kBACA,KAAA,iBAAA,MAAA,KAAA,YAGA,WAAA,SAAA,EAAA,GACA,GAAA,GAAA,GAAA,kBAAA,SAAA,GACA,EAAA,KAAA,KAAA,EAAA,GACA,EAAA,cACA,KAAA,MACA,GAAA,QAAA,GAAA,WAAA,EAAA,SAAA,KAYA,GAAA,UAAA,EACA,EAAA,YAAA,EAIA,EAAA,KAAA,EACA,EAAA,OAAA,EACA,EAAA,IAAA,SAAA,KAAA,GAEA,SCtMA,SAAA,GAsEA,QAAA,GAAA,GACA,MAAA,GAAA,UAnEA,GAIA,IAJA,OAAA,aAIA,WACA,EAAA,aAEA,GACA,sBAAA,EAmBA,wBAAA,WAEA,GAAA,GAAA,KAAA,qBACA,IAAA,IAAA,KAAA,qBAAA,EAAA,GAAA,CAGA,IADA,GAAA,GAAA,EAAA,MAAA,EAAA,GACA,GAAA,EAAA,SACA,GAAA,EAAA,QAAA,gBAAA,GACA,EAAA,EAAA,EAEA,IAAA,EAAA,CACA,GAAA,GAAA,KAAA,QAAA,oBAAA,EACA,EAGA,SAAA,kBAAA,EAAA,MAIA,oBAAA,WACA,GAAA,OAAA,kBACA,MAAA,MAAA,SAAA,KAIA,KADA,GAAA,GAAA,KACA,EAAA,YACA,EAAA,EAAA,UAEA,OAAA,KAAA,SAAA,SAAA,KAAA,GAGA,qBAAA,SAAA,EAAA,GACA,GAAA,GAAA,EAAA,IAAA,KAAA,UAAA,IAAA,CACA,OAAA,GAAA,cAAA,SAAA,EAAA,MAYA,GAAA,IAAA,SAAA,OAAA,GAEA,SC7EA,SAAA,GAEA,GAAA,IACA,oBAAA,SAAA,GACA,EAAA,mBAAA,IAEA,kBAAA,WACA,GAAA,GAAA,KAAA,cAEA,EAAA,KAAA,aAAA,cAAA,GACA,EAAA,KAAA,OACA,MAAA,UAAA,YAAA,SAAA,EAAA,GACA,GAAA,EACA,MAAA,MAAA,QAAA,UAAA,GAAA,CAEA,IAAA,GAAA,CACA,IAAA,EAAA,CAEA,GAAA,GAAA,EAAA,MAAA,EAAA,GACA,GAAA,EAAA,EAAA,GAEA,MAAA,GAAA,EAAA,IAGA,YAAA,WACA,MAAA,MAAA,UAAA,EAAA,eAAA,KAAA,iBAEA,QAAA,SAAA,EAAA,GAMA,IALA,GAAA,GAAA,EAAA,MAAA,KACA,EAAA,EAAA,MAAA,KAGA,GAAA,EACA,EAAA,QAAA,EAAA,QAAA,EAAA,KAAA,EAAA,IACA,EAAA,QACA,EAAA,QACA,GAAA,CAIA,IAAA,EACA,IAAA,GAAA,GAAA,EAAA,EAAA,EAAA,OAAA,IACA,EAAA,QAAA,KAGA,OAAA,GAAA,KAAA,MAEA,UAAA,SAAA,GACA,GAAA,EAEA,CACA,GAAA,GAAA,EAAA,MAAA,IAGA,OAFA,GAAA,MACA,EAAA,KAAA,IACA,EAAA,KAAA,KALA,MAAA,KAUA,GAAA,OAAA,MAAA,UACA,EAAA,IAAA,EAAA,KAAA,OAAA,IACA,EAAA,SACA,EAAA,sBACA,EAAA,4BAEA,GACA,QAAA,SAAA,GACA,GAAA,GAAA,EAAA,oBAAA,EACA,OAAA,GAAA,WAAA,EAAA,EAAA,UAAA,KAGA,UAAA,SAAA,GACA,MAAA,GAAA,aAAA,SAAA,EAAA,aAAA,QAEA,oBAAA,SAAA,GACA,MAAA,GAAA,eAAA,EAAA,eAAA,IAEA,eAAA,SAAA,GACA,GAAA,GAAA,IAEA,EAAA,MAAA,EAAA,MAAA,EAAA,KAAA,MACA,EAAA,SAAA,EAAA,MACA,EAEA,OAAA,GAAA,MAAA,KAAA,IAEA,WAAA,SAAA,EAAA,GACA,MAAA,MAAA,SAAA,GACA,EAEA,KAAA,YAAA,KAAA,UAAA,GAAA,IAEA,mBAAA,SAAA,EAAA,GACA,MAAA,MAAA,SAAA,GACA,EAEA,KAAA,oBAAA,KAAA,WAAA,EAAA,KAEA,SAAA,SAAA,GACA,MAAA,8BAAA,KAAA,IAEA,UAAA,SAAA,GACA,GAAA,GAAA,EAAA,MAAA,IAGA,OAFA,GAAA,MACA,EAAA,KAAA,IACA,EAAA,KAAA,MAEA,YAAA,SAAA,GACA,GAAA,GAAA,GACA,EAAA,EAAA,QAAA,IAEA,GAAA,KACA,EAAA,EAAA,UAAA,GACA,EAAA,EAAA,UAAA,EAAA,GAGA,KAAA,GAAA,GADA,EAAA,EAAA,MAAA,KACA,EAAA,EAAA,EAAA,EAAA,OAAA,IACA,EAAA,EAAA,GACA,OAAA,IACA,EAAA,OAAA,EAAA,EAAA,GACA,GAAA,EAGA,OAAA,GAAA,KAAA,KAAA,GAEA,oBAAA,SAAA,GAIA,MAFA,GAAA,OAAA,KAAA,GAEA,EAAA,OAAA,OACA,OAAA,SAAA,MAAA,OAAA,EAAA,OAAA,MACA,EAAA,OAAA,WAAA,OAAA,SAAA,UACA,EAAA,OAAA,OAAA,OAAA,SAAA,MACA,EAAA,OAAA,WAAA,OAAA,SAAA,SACA,KAAA,YAAA,EAAA,YAAA,EAAA,OAAA,MAEA,GAIA,YAAA,SAAA,EAAA,GAGA,IAFA,GAAA,GAAA,EAAA,MAAA,KACA,EAAA,EAAA,MAAA,KACA,EAAA,QAAA,EAAA,KAAA,EAAA,IACA,EAAA,QACA,EAAA,OAEA,KAAA,GAAA,GAAA,EAAA,EAAA,EAAA,OAAA,EAAA,EAAA,EAAA,IACA,EAAA,QAAA,KAEA,IAAA,GAAA,EAAA,KAAA,IACA,OAAA,IAEA,WAAA,SAAA,GAEA,MADA,GAAA,OAAA,KAAA,EACA,EAAA,OAAA,MAEA,mBAAA,SAAA,EAAA,GACA,EAAA,GAAA,EAAA,oBAAA,GACA,EAAA,eAAA,EAAA,iBACA,EAAA,sBAAA,EAAA,GAEA,EAAA,kBAAA,EAAA,GACA,EAAA,iBAAA,EAAA,EAEA,IAAA,GAAA,EAAA,iBAAA,WACA,IAAA,EACA,IAAA,GAAA,GAAA,EAAA,EAAA,EAAA,EAAA,OAAA,EAAA,IAAA,EAAA,EAAA,IAAA,IACA,EAAA,SACA,EAAA,mBAAA,EAAA,QAAA,IAKA,yBAAA,SAAA,GACA,GAAA,GAAA,EAAA,QAAA,EACA,GAAA,WAAA,EAAA,eAAA,EAAA,WAAA,IAEA,iBAAA,SAAA,EAAA,GACA,GAAA,GAAA,EAAA,iBAAA,QACA,IAAA,EACA,IAAA,GAAA,GAAA,EAAA,EAAA,EAAA,EAAA,OAAA,EAAA,IAAA,EAAA,EAAA,IAAA,IACA,EAAA,gBAAA,EAAA,IAIA,gBAAA,SAAA,EAAA,GACA,EAAA,GAAA,EAAA,oBAAA,GACA,EAAA,YAAA,EAAA,eAAA,EAAA,YAAA,IAEA,eAAA,SAAA,EAAA,GACA,GAAA,GAAA,EAAA,qBAAA,EAAA,EAAA,EACA,OAAA,GAAA,qBAAA,EAAA,EAAA,IAEA,qBAAA,SAAA,EAAA,EAAA,GACA,MAAA,GAAA,QAAA,EAAA,SAAA,EAAA,EAAA,EAAA,GACA,GAAA,GAAA,EAAA,QAAA,QAAA,GAEA,OADA,GAAA,EAAA,mBAAA,EAAA,GACA,EAAA,IAAA,EAAA,IAAA,KAGA,kBAAA,SAAA,EAAA,GAEA,GAAA,GAAA,GAAA,EAAA,iBAAA,EACA,IAAA,EACA,IAAA,GAAA,GAAA,EAAA,EAAA,EAAA,EAAA,OAAA,EAAA,IAAA,EAAA,EAAA,IAAA,IACA,KAAA,sBAAA,EAAA,IAIA,sBAAA,SAAA,EAAA,GACA,EAAA,GAAA,EAAA,oBAAA,GACA,EAAA,QAAA,SAAA,GACA,GAAA,GAAA,EAAA,WAAA,EACA,IAAA,GAAA,EAAA,OACA,EAAA,MAAA,OAAA,GAAA,EAAA,CACA,GAAA,GAAA,EAAA,mBAAA,EAAA,EAAA,MACA,GAAA,MAAA,MAMA,GAAA,YAAA,EAAA,eAAA,UACA,EAAA,OAAA,SAAA,cAAA,KAGA,EAAA,IAAA,YAAA,KAAA,EACA,EAAA,aAAA,GAEA,SCvOA,SAAA,GAsLA,QAAA,GAAA,GACA,MAAA,YAAA,EAAA,KAAA,KAGA,QAAA,GAAA,EAAA,GACA,GAAA,EAAA,CAMA,GAAA,GAAA,EAAA,EAAA,aACA,EAAA,EAAA,aAAA,EACA,IACA,EAAA,aAAA,EAAA,GAEA,EAAA,YAAA,IAIA,QAAA,GAAA,EAAA,GACA,EAAA,GAAA,SACA,EAAA,EAAA,cAAA,EAAA,EAAA,aACA,IAAA,GAAA,EAAA,cAAA,QAEA,OADA,GAAA,YAAA,EACA,EAGA,QAAA,GAAA,GACA,MAAA,IAAA,EAAA,YAAA,GAGA,QAAA,GAAA,EAAA,GACA,MAAA,GACA,EAAA,KAAA,EAAA,GADA,OAnNA,GACA,IADA,OAAA,aACA,EAAA,IAAA,SAAA,QACA,EAAA,EAAA,sBAIA,EAAA,QACA,EAAA,UACA,EAAA,uBACA,EAAA,SACA,EAAA,gBAEA,GAEA,WAAA,SAAA,GACA,GAAA,GAAA,KAAA,iBACA,IACA,KAAA,sBAAA,EAEA,IAAA,GAAA,KAAA,mBAAA,EACA,GAAA,OAKA,OAAA,mBAAA,KAAA,aAAA,iBACA,SAAA,OAAA,UAAA,EAAA,GAEA,SAAA,OAAA,YAAA,EAAA,GAEA,GACA,KAGA,sBAAA,SAAA,GAEA,IAAA,GAAA,GAAA,EADA,EAAA,EAAA,iBAAA,GACA,EAAA,EAAA,EAAA,EAAA,OAAA,EAAA,IAAA,EAAA,EAAA,IAAA,IAAA,CACA,EAAA,EAAA,EAAA,GAAA,EAAA,cACA,IAAA,GAAA,EAAA,aAAA,EACA,IACA,EAAA,aAAA,EAAA,GAEA,EAAA,WAAA,aAAA,EAAA,KAGA,mBAAA,SAAA,GACA,GAAA,KACA,IAAA,EAEA,IAAA,GAAA,GADA,EAAA,EAAA,iBAAA,GACA,EAAA,EAAA,EAAA,EAAA,OAAA,EAAA,IAAA,EAAA,EAAA,IAAA,IACA,EAAA,YAAA,MAAA,IACA,EAAA,KAAA,EAIA,OAAA,IAeA,cAAA,WACA,KAAA,cACA,KAAA,cACA,KAAA,qBACA,KAAA,uBAKA,YAAA,WACA,KAAA,OAAA,KAAA,UAAA,GACA,KAAA,OAAA,QAAA,SAAA,GACA,EAAA,YACA,EAAA,WAAA,YAAA,MAIA,YAAA,WACA,KAAA,OAAA,KAAA,UAAA,EAAA,IAAA,EAAA,KACA,KAAA,OAAA,QAAA,SAAA,GACA,EAAA,YACA,EAAA,WAAA,YAAA,MAaA,mBAAA,WACA,GAAA,GAAA,KAAA,OAAA,OAAA,SAAA,GACA,OAAA,EAAA,aAAA,KAEA,EAAA,KAAA,iBACA,IAAA,EAAA,CACA,GAAA,GAAA,EAIA,IAHA,EAAA,QAAA,SAAA,GACA,GAAA,EAAA,GAAA,OAEA,EAAA,CACA,GAAA,GAAA,EAAA,EAAA,KAAA,cACA,GAAA,aAAA,EAAA,EAAA,eAIA,UAAA,SAAA,EAAA,GACA,GAAA,GAAA,KAAA,iBAAA,GAAA,QACA,EAAA,KAAA,iBACA,IAAA,EAAA,CACA,GAAA,GAAA,EAAA,iBAAA,GAAA,OACA,GAAA,EAAA,OAAA,GAEA,MAAA,GAAA,EAAA,OAAA,GAAA,GAEA,gBAAA,WACA,GAAA,GAAA,KAAA,cAAA,WACA,OAAA,IAAA,gBAAA,IAWA,oBAAA,WACA,GAAA,GAAA,KAAA,cAAA,EACA,GAAA,EAAA,SAAA,OAEA,gBAAA,SAAA,GACA,GAAA,GAAA,GAEA,EAAA,IAAA,EAAA,IAAA,EAAA,IACA,EAAA,SAAA,GACA,MAAA,GAAA,EAAA,IAEA,EAAA,KAAA,OAAA,OAAA,EACA,GAAA,QAAA,SAAA,GACA,GAAA,EAAA,GAAA,QAGA,IAAA,GAAA,KAAA,OAAA,OAAA,EAIA,OAHA,GAAA,QAAA,SAAA,GACA,GAAA,EAAA,YAAA,SAEA,GAEA,cAAA,SAAA,GACA,GAAA,GAAA,KAAA,gBAAA,EACA,OAAA,MAAA,oBAAA,EAAA,IAEA,oBAAA,SAAA,EAAA,GACA,GAAA,EAAA,CACA,GAAA,GAAA,EAAA,EAGA,OAFA,GAAA,aAAA,EAAA,KAAA,aAAA,QACA,IAAA,GACA,KA0CA,EAAA,YAAA,UACA,EAAA,EAAA,SAAA,EAAA,iBAAA,EAAA,uBACA,EAAA,kBAIA,GAAA,IAAA,YAAA,OAAA,EACA,EAAA,kBAAA,GAEA,SCnOA,SAAA,GAIA,GAAA,GAAA,EAAA,IAAA,SAAA,OAKA,GAJA,OAAA,cAKA,gBAAA,WAEA,GAAA,GAAA,KAAA,UAAA,cAEA,MAAA,sBAAA,IAEA,sBAAA,SAAA,GAEA,IAAA,GAAA,GAAA,EAAA,EAAA,EAAA,KAAA,WAAA,GAAA,IAEA,EAAA,eAAA,EAAA,QAEA,EAAA,EAAA,kBAAA,EAAA,OAAA,EAAA,MAAA,QAAA,KAAA,IACA,QAAA,KAAA,IAAA,SAIA,oBACA,qBAAA,uBACA,mBAAA,qBACA,oBAAA,sBACA,YAAA,cACA,WAAA,aACA,eAAA,mBAMA,GAAA,IAAA,YAAA,OAAA,GAEA,SC1CA,SAAA,GAIA,GAAA,IACA,eAAA,SAAA,GAEA,GAAA,GAAA,EAAA,EAAA,OACA,KAAA,GAAA,KAAA,GACA,YAAA,EAAA,MAAA,MACA,IACA,EAAA,EAAA,YAEA,EAAA,EAAA,MAAA,EAAA,IACA,EAAA,GAAA,EAAA,IAAA,IAIA,iBAAA,SAAA,GAEA,GAAA,GAAA,EAAA,OACA,IAAA,EAAA,CACA,GAAA,KACA,KAAA,GAAA,KAAA,GAEA,IAAA,GAAA,GADA,EAAA,EAAA,MAAA,KACA,EAAA,EAAA,EAAA,EAAA,GAAA,IACA,EAAA,GAAA,EAAA,EAGA,GAAA,QAAA,IAGA,qBAAA,SAAA,GACA,GAAA,EAAA,QAAA,CAEA,GAAA,GAAA,EAAA,gBACA,KAAA,GAAA,KAAA,GAAA,QAEA,IAAA,GAAA,GADA,EAAA,EAAA,MAAA,KACA,EAAA,EAAA,EAAA,EAAA,GAAA,IACA,EAAA,KAAA,GAKA,GAAA,EAAA,QAAA,CAEA,GAAA,GAAA,EAAA,gBACA,KAAA,GAAA,KAAA,GAAA,QACA,EAAA,KAAA,KAIA,kBAAA,SAAA,EAAA,GAEA,GAAA,GAAA,EAAA,OACA,KAEA,KAAA,kBAAA,EAAA,EAAA,GAEA,EAAA,WAAA,KAAA,aAAA,KAGA,kBAAA,SAAA,EAAA,EAAA,GAEA,IAAA,GAAA,KAAA,GACA,SAAA,EAAA,IAAA,SAAA,EAAA,KACA,EAAA,GAAA,EAAA,KAIA,aAAA,SAAA,GACA,GAAA,KACA,KAAA,GAAA,KAAA,GACA,EAAA,EAAA,eAAA,CAEA,OAAA,IAMA,GAAA,IAAA,YAAA,WAAA,GAEA,SCnFA,SAAA,GAIA,GAAA,GAAA,aACA,EAAA,OAIA,GACA,yBAAA,SAAA,GAEA,KAAA,cAAA,EAAA,aAEA,KAAA,cAAA,EAAA,wBAEA,kBAAA,SAAA,EAAA,GAEA,GAAA,GAAA,KAAA,aAAA,EACA,IAAA,EAMA,IAAA,GAAA,GAJA,EAAA,EAAA,UAAA,EAAA,YAEA,EAAA,EAAA,MAAA,GAEA,EAAA,EAAA,EAAA,EAAA,OAAA,EAAA,EAAA,IAEA,EAAA,EAAA,GAAA,OAEA,GAAA,SAAA,EAAA,IAAA,SAAA,EAAA,KACA,EAAA,GAAA,OAMA,6BAAA,WAKA,IAAA,GAAA,GAHA,EAAA,KAAA,UAAA,oBAEA,EAAA,KAAA,WACA,EAAA,EAAA,EAAA,EAAA,OAAA,EAAA,IAAA,EAAA,EAAA,IAAA,IACA,KAAA,oBAAA,EAAA,QACA,EAAA,EAAA,MAAA,EAAA,QAIA,oBAAA,SAAA,GACA,OAAA,KAAA,UAAA,IAAA,QAAA,EAAA,MAAA,EAAA,IAGA,WAAA,KAAA,EAAA,UAAA,EAAA,YAAA,EAAA,SAAA,GAIA,GAAA,UAAA,GAAA,EAIA,EAAA,IAAA,YAAA,WAAA,GAEA,SC7DA,SAAA,GAoOA,QAAA,GAAA,GACA,IAAA,OAAA,UAAA,CACA,GAAA,GAAA,OAAA,eAAA,EACA,GAAA,UAAA,EACA,EAAA,KACA,EAAA,UAAA,OAAA,eAAA,KArOA,GAAA,GAAA,EAAA,IACA,EAAA,EAAA,OACA,EAAA,EAAA,OAIA,GACA,SAAA,SAAA,EAAA,GAEA,KAAA,UAAA,KAAA,eAAA,EAAA,GAGA,KAAA,UAAA,QAAA,KAEA,KAAA,QAAA,EAAA,GAEA,KAAA,kBAAA,EAAA,GAEA,KAAA,sBAEA,eAAA,SAAA,EAAA,GAEA,GAAA,GAAA,EAAA,uBAAA,GAEA,EAAA,KAAA,sBAAA,EAiBA,OAfA,MAAA,kBAAA,EAAA,GAEA,KAAA,kBAAA,EAAA,GAEA,KAAA,eAAA,GAEA,KAAA,iBAAA,GAEA,KAAA,gBAAA,EAAA,GAEA,EAAA,KAAA,YAAA,EAAA,GAEA,KAAA,qBAAA,GAEA,EAAA,GACA,GAEA,gBAAA,SAAA,EAAA,GAEA,KAAA,cAAA,UAAA,EAAA,GAEA,KAAA,cAAA,UAAA,EAAA,GAEA,KAAA,cAAA,aAAA,EAAA,GAEA,KAAA,cAAA,sBAAA,EAAA,GAEA,KAAA,cAAA,iBAAA,EAAA,IAGA,QAAA,SAAA,EAAA,GAEA,KAAA,gBAEA,KAAA,oBAAA,MAEA,KAAA,+BAEA,KAAA,kBAEA,KAAA,sBAOA,KAAA,oBAEA,OAAA,mBACA,SAAA,UAAA,YAAA,KAAA,kBAAA,EAAA,GAGA,KAAA,UAAA,kBACA,KAAA,UAAA,iBAAA,OAMA,oBAAA,WAGA,IAAA,OAAA,kBAAA,CACA,GAAA,GAAA,KAAA,iBACA,IAAA,EAEA,IAAA,GAAA,GADA,EAAA,EAAA,iBAAA,UACA,EAAA,EAAA,EAAA,EAAA,OAAA,EAAA,IAAA,EAAA,EAAA,IAAA,IACA,EAAA,SAAA,QACA,EAAA,YAAA,SAAA,cAAA,cAQA,mBAAA,WACA,GAAA,GAAA,KAAA,aAAA,cACA,KACA,OAAA,GAAA,KAAA,OAIA,sBAAA,SAAA,GACA,GAAA,GAAA,KAAA,kBAAA,EACA,KAAA,EAAA,CAEA,GAAA,GAAA,YAAA,mBAAA,EAEA,GAAA,KAAA,cAAA,GAEA,cAAA,GAAA,EAEA,MAAA,IAEA,kBAAA,SAAA,GACA,MAAA,eAAA,IAGA,cAAA,SAAA,GACA,GAAA,EAAA,YACA,MAAA,EAEA,IAAA,GAAA,OAAA,OAAA,EAKA,KAAA,GAAA,KAAA,GAAA,SACA,EAAA,EAAA,EAAA,SAAA,GAgBA,OAFA,MAAA,YAAA,EAAA,EAAA,EAAA,SAAA,IAAA,QAEA,GAEA,YAAA,SAAA,EAAA,EAAA,EAAA,GACA,GAAA,GAAA,SAAA,GACA,MAAA,GAAA,GAAA,MAAA,KAAA,GAEA,GAAA,GAAA,WAEA,MADA,MAAA,WAAA,EACA,EAAA,GAAA,MAAA,KAAA,aAIA,cAAA,SAAA,EAAA,EAAA,GAEA,GAAA,GAAA,EAAA,MAEA,GAAA,GAAA,KAAA,YAAA,EAAA,EAAA,KAGA,kBAAA,SAAA,EAAA,GACA,GAAA,IACA,UAAA,KAAA,WAGA,EAAA,KAAA,kBAAA,EACA,KACA,EAAA,QAAA,GAGA,KAAA,KAAA,SAAA,gBAAA,EAAA,GAEA,KAAA,UAAA,YAAA,KAAA,KAEA,YAAA,SAAA,EAAA,KAAA,YAEA,kBAAA,SAAA,GACA,GAAA,GAAA,EAAA,QAAA,KAAA,EACA,MAAA,EAEA,IAAA,GAAA,KAAA,kBAAA,EACA,OAAA,GAAA,QACA,KAAA,kBAAA,EAAA,QAAA,SADA,QASA,GAAA,YADA,OAAA,UACA,SAAA,EAAA,GAIA,MAHA,IAAA,GAAA,IAAA,IACA,EAAA,UAAA,GAEA,GAGA,SAAA,EAAA,GACA,GAAA,GAAA,GAAA,IAAA,EAAA,CACA,GAAA,GAAA,OAAA,OAAA,EACA,GAAA,EAAA,EAAA,GAEA,MAAA,IAKA,iBAkBA,EAAA,YAAA,UAAA,GAEA,SClPA,SAAA,GAgGA,QAAA,GAAA,GACA,MAAA,UAAA,SAAA,GAAA,EAAA,EAGA,QAAA,KACA,MAAA,GAAA,OAAA,EAAA,GAAA,EAAA,GAKA,QAAA,GAAA,GACA,EAAA,aAAA,EACA,YAAA,iBAAA,WACA,EAAA,iBAAA,GACA,EAAA,aAAA,EACA,EAAA,UA7GA,GAAA,IAEA,KAAA,SAAA,GAKA,MAJA,KAAA,KAAA,QAAA,IACA,KAAA,EAAA,QAAA,IACA,KAAA,IAAA,GAEA,IAAA,KAAA,QAAA,IAEA,IAAA,SAAA,GAEA,EAAA,GAAA,KAAA,IAEA,QAAA,SAAA,GACA,GAAA,GAAA,EAAA,GAAA,QAAA,EAKA,OAJA,IAAA,GAAA,SAAA,SAAA,KACA,GAAA,YAAA,WAAA,YAAA,MAAA,EAAA,OACA,KAEA,GAGA,SAAA,SAAA,GACA,GAAA,GAAA,KAAA,OAAA,EACA,KACA,EAAA,KAAA,GACA,KAAA,UAGA,OAAA,SAAA,GACA,GAAA,GAAA,KAAA,QAAA,EACA,IAAA,IAAA,EAIA,MAAA,GAAA,GAAA,SAEA,MAAA,WAEA,GAAA,GAAA,KAAA,aAIA,OAHA,IACA,EAAA,oBAEA,KAAA,YACA,KAAA,SACA,GAFA,QAKA,YAAA,WACA,MAAA,MAEA,SAAA,WACA,OAAA,KAAA,aAAA,KAAA,WAEA,QAAA,WACA,OAAA,EAAA,SAAA,EAAA,QAEA,MAAA,WAOA,eAAA,OAAA,CAEA,KADA,GAAA,GACA,EAAA,QACA,EAAA,EAAA,QACA,EAAA,WAEA,gBAAA,oBAAA,UACA,eAAA,OAAA,EACA,KAAA,uBAEA,oBAAA,WACA,GAAA,EAEA,IADA,GAAA,GACA,EAAA,SACA,EAAA,EAAA,YAKA,iBAAA,SAAA,GACA,EAAA,KAAA,IAEA,aAAA,GAGA,KACA,KACA,KACA,IAsBA,GAAA,MAAA,EACA,EAAA,iBAAA,GACA,SCtHA,SAAA,GAYA,QAAA,GAAA,EAAA,GAGA,EAAA,GAAA,MAEA,EAAA,GAoGA,QAAA,GAAA,GACA,MAAA,GAAA,GAMA,QAAA,GAAA,GACA,EAAA,KACA,EAAA,GAAA,0BACA,GAAA,IA3HA,GAAA,GAAA,EAAA,OACA,EAAA,EAAA,IAAA,YACA,EAAA,EAAA,MACA,EAAA,EAAA,iBAeA,EAAA,EAAA,OAAA,OAAA,YAAA,YACA,gBAAA,WACA,KAAA,aAAA,SACA,KAAA,QAGA,KAAA,WAEA,KAAA,KAAA,KAAA,aAAA,QAGA,KAAA,QAAA,KAAA,aAAA,WACA,KAAA,gBACA,KAAA,qBAEA,kBAAA,WACA,KAAA,YAIA,KAAA,oBAAA,KAAA,OAGA,KAAA,mBAGA,KAAA,uBAGA,KAAA,mBAEA,gBAAA,WACA,EAAA,SAAA,OAEA,UAAA,WAGA,KAAA,SAAA,KAAA,KAAA,KAAA,SACA,KAAA,YAAA,GAGA,oBAAA,SAAA,GACA,IAAA,EAAA,GAAA,CAIA,GAFA,EAAA,GAAA,KAEA,KAAA,aAAA,cAAA,KAAA,SAQA,GAPA,KAAA,UAAA,EAOA,OAAA,iBAAA,eAAA,UACA,EAAA,OACA,CACA,GAAA,GAAA,SAAA,cAAA,SACA,GAAA,YAAA,YAAA,EAAA,MACA,KAAA,YAAA,GAGA,OAAA,IAGA,oBAAA,WACA,MAAA,MAAA,iBAKA,gBAAA,WACA,MAAA,GAAA,KAAA,OAEA,cAAA,WACA,KAAA,iBAAA,EACA,KAAA,WAAA,WACA,KAAA,iBAAA,EACA,KAAA,qBACA,KAAA,SAOA,QAAA,KAAA,GAAA,QAAA,SAAA,GACA,EAAA,EAAA,EAAA,KAMA,IAAA,MAOA,IAiBA,GAAA,uBAAA,EAOA,EAAA,EAAA,GAEA,OAAA,QAAA,CAKA,IAAA,GAAA,SAAA,qBACA,IAAA,EACA,IAAA,GAAA,GAAA,EAAA,EAAA,EAAA,EAAA,OAAA,EAAA,IAAA,EAAA,EAAA,IAAA,IACA,EAAA,MAAA,KAAA,EAIA,GAAA,WACA,SAAA,cACA,GAAA,aAAA,iBAAA,SAAA,OAKA,SAAA,gBAAA,mBAAA,UAAA,KACA","sourcesContent":["/*\n * Copyright 2013 The Polymer Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style\n * license that can be found in the LICENSE file.\n */\nPolymer = {};\n","/*\n * Copyright 2013 The Polymer Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style\n * license that can be found in the LICENSE file.\n */\n\n\n// TODO(sorvell): this ensures Polymer is an object and not a function\n// Platform is currently defining it as a function to allow for async loading\n// of polymer; once we refine the loading process this likely goes away.\nif (typeof window.Polymer === 'function') {\n  Polymer = {};\n}","/*\n * Copyright 2013 The Polymer Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style\n * license that can be found in the LICENSE file.\n */\n(function(scope) {\n\n  // copy own properties from 'api' to 'prototype, with name hinting for 'super'\n  function extend(prototype, api) {\n    if (prototype && api) {\n      // use only own properties of 'api'\n      Object.getOwnPropertyNames(api).forEach(function(n) {\n        // acquire property descriptor\n        var pd = Object.getOwnPropertyDescriptor(api, n);\n        if (pd) {\n          // clone property via descriptor\n          Object.defineProperty(prototype, n, pd);\n          // cache name-of-method for 'super' engine\n          if (typeof pd.value == 'function') {\n            // hint the 'super' engine\n            pd.value.nom = n;\n          }\n        }\n      });\n    }\n    return prototype;\n  }\n  \n  // exports\n\n  scope.extend = extend;\n\n})(Polymer);\n","/* \n * Copyright 2013 The Polymer Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style\n * license that can be found in the LICENSE file.\n */\n\n(function(scope) {\n  \n  // usage\n  \n  // invoke cb.call(this) in 100ms, unless the job is re-registered,\n  // which resets the timer\n  // \n  // this.myJob = this.job(this.myJob, cb, 100)\n  //\n  // returns a job handle which can be used to re-register a job\n\n  var Job = function(inContext) {\n    this.context = inContext;\n    this.boundComplete = this.complete.bind(this)\n  };\n  Job.prototype = {\n    go: function(callback, wait) {\n      this.callback = callback;\n      var h;\n      if (!wait) {\n        h = requestAnimationFrame(this.boundComplete);\n        this.handle = function() {\n          cancelAnimationFrame(h);\n        }\n      } else {\n        h = setTimeout(this.boundComplete, wait);\n        this.handle = function() {\n          clearTimeout(h);\n        }\n      }\n    },\n    stop: function() {\n      if (this.handle) {\n        this.handle();\n        this.handle = null;\n      }\n    },\n    complete: function() {\n      if (this.handle) {\n        this.stop();\n        this.callback.call(this.context);\n      }\n    }\n  };\n  \n  function job(job, callback, wait) {\n    if (job) {\n      job.stop();\n    } else {\n      job = new Job(this);\n    }\n    job.go(callback, wait);\n    return job;\n  }\n  \n  // exports \n\n  scope.job = job;\n  \n})(Polymer);\n","/*\n * Copyright 2013 The Polymer Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style\n * license that can be found in the LICENSE file.\n */\n(function(scope) {\n\n  var registry = {};\n\n  HTMLElement.register = function(tag, prototype) {\n    registry[tag] = prototype;\n  }\n\n  // get prototype mapped to node <tag>\n  HTMLElement.getPrototypeForTag = function(tag) {\n    var prototype = !tag ? HTMLElement.prototype : registry[tag];\n    // TODO(sjmiles): creating <tag> is likely to have wasteful side-effects\n    return prototype || Object.getPrototypeOf(document.createElement(tag));\n  };\n\n  // we have to flag propagation stoppage for the event dispatcher\n  var originalStopPropagation = Event.prototype.stopPropagation;\n  Event.prototype.stopPropagation = function() {\n    this.cancelBubble = true;\n    originalStopPropagation.apply(this, arguments);\n  };\n  \n  // TODO(sorvell): remove when we're sure imports does not need\n  // to load stylesheets\n  /*\n  HTMLImports.importer.preloadSelectors += \n      ', polymer-element link[rel=stylesheet]';\n  */\n})(Polymer);\n","/*\n * Copyright 2013 The Polymer Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style\n * license that can be found in the LICENSE file.\n */\n (function(scope) {\n    // super\n\n    // `arrayOfArgs` is an optional array of args like one might pass\n    // to `Function.apply`\n\n    // TODO(sjmiles):\n    //    $super must be installed on an instance or prototype chain\n    //    as `super`, and invoked via `this`, e.g.\n    //      `this.super();`\n\n    //    will not work if function objects are not unique, for example,\n    //    when using mixins.\n    //    The memoization strategy assumes each function exists on only one \n    //    prototype chain i.e. we use the function object for memoizing)\n    //    perhaps we can bookkeep on the prototype itself instead\n    function $super(arrayOfArgs) {\n      // since we are thunking a method call, performance is important here: \n      // memoize all lookups, once memoized the fast path calls no other \n      // functions\n      //\n      // find the caller (cannot be `strict` because of 'caller')\n      var caller = $super.caller;\n      // memoized 'name of method' \n      var nom = caller.nom;\n      // memoized next implementation prototype\n      var _super = caller._super;\n      if (!_super) {\n        if (!nom) {\n          nom = caller.nom = nameInThis.call(this, caller);\n        }\n        if (!nom) {\n          console.warn('called super() on a method not installed declaratively (has no .nom property)');\n        }\n        // super prototype is either cached or we have to find it\n        // by searching __proto__ (at the 'top')\n        _super = memoizeSuper(caller, nom, getPrototypeOf(this));\n      }\n      if (!_super) {\n        // if _super is falsey, there is no super implementation\n        //console.warn('called $super(' + nom + ') where there is no super implementation');\n      } else {\n        // our super function\n        var fn = _super[nom];\n        // memoize information so 'fn' can call 'super'\n        if (!fn._super) {\n          memoizeSuper(fn, nom, _super);\n        }\n        // invoke the inherited method\n        // if 'fn' is not function valued, this will throw\n        return fn.apply(this, arrayOfArgs || []);\n      }\n    }\n\n    function nextSuper(proto, name, caller) {\n      // look for an inherited prototype that implements name\n      while (proto) {\n        if ((proto[name] !== caller) && proto[name]) {\n          return proto;\n        }\n        proto = getPrototypeOf(proto);\n      }\n    }\n\n    function memoizeSuper(method, name, proto) {\n      // find and cache next prototype containing `name`\n      // we need the prototype so we can do another lookup\n      // from here\n      method._super = nextSuper(proto, name, method);\n      if (method._super) {\n        // _super is a prototype, the actual method is _super[name]\n        // tag super method with it's name for further lookups\n        method._super[name].nom = name;\n      }\n      return method._super;\n    }\n\n    function nameInThis(value) {\n      var p = this.__proto__;\n      while (p && p !== HTMLElement.prototype) {\n        // TODO(sjmiles): getOwnPropertyNames is absurdly expensive\n        var n$ = Object.getOwnPropertyNames(p);\n        for (var i=0, l=n$.length, n; i<l && (n=n$[i]); i++) {\n          var d = Object.getOwnPropertyDescriptor(p, n);\n          if (typeof d.value === 'function' && d.value === value) {\n            return n;\n          }\n        }\n        p = p.__proto__;\n      }\n    }\n\n    // NOTE: In some platforms (IE10) the prototype chain is faked via \n    // __proto__. Therefore, always get prototype via __proto__ instead of\n    // the more standard Object.getPrototypeOf.\n    function getPrototypeOf(prototype) {\n      return prototype.__proto__;\n    }\n\n    // utility function to precompute name tags for functions\n    // in a (unchained) prototype\n    function hintSuper(prototype) {\n      // tag functions with their prototype name to optimize\n      // super call invocations\n      for (var n in prototype) {\n        var pd = Object.getOwnPropertyDescriptor(prototype, n);\n        if (pd && typeof pd.value === 'function') {\n          pd.value.nom = n;\n        }\n      }\n    }\n\n    // exports\n\n    scope.super = $super;\n\n})(Polymer);\n","/* \n * Copyright 2013 The Polymer Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style\n * license that can be found in the LICENSE file.\n */\n\n(function(scope) {\n\n  var typeHandlers = {\n    string: function(value) {\n      return value;\n    },\n    date: function(value) {\n      return new Date(Date.parse(value) || Date.now());\n    },\n    boolean: function(value) {\n      if (value === '') {\n        return true;\n      }\n      return value === 'false' ? false : !!value;\n    },\n    number: function(value) {\n      var n = parseFloat(value);\n      // hex values like \"0xFFFF\" parseFloat as 0\n      if (n === 0) {\n        n = parseInt(value);\n      }\n      return isNaN(n) ? value : n;\n      // this code disabled because encoded values (like \"0xFFFF\")\n      // do not round trip to their original format\n      //return (String(floatVal) === value) ? floatVal : value;\n    },\n    object: function(value, currentValue) {\n      if (currentValue === null) {\n        return value;\n      }\n      try {\n        // If the string is an object, we can parse is with the JSON library.\n        // include convenience replace for single-quotes. If the author omits\n        // quotes altogether, parse will fail.\n        return JSON.parse(value.replace(/'/g, '\"'));\n      } catch(e) {\n        // The object isn't valid JSON, return the raw value\n        return value;\n      }\n    },\n    // avoid deserialization of functions\n    'function': function(value, currentValue) {\n      return currentValue;\n    }\n  };\n\n  function deserializeValue(value, currentValue) {\n    // attempt to infer type from default value\n    var inferredType = typeof currentValue;\n    // invent 'date' type value for Date\n    if (currentValue instanceof Date) {\n      inferredType = 'date';\n    }\n    // delegate deserialization via type string\n    return typeHandlers[inferredType](value, currentValue);\n  }\n\n  // exports\n\n  scope.deserializeValue = deserializeValue;\n\n})(Polymer);\n","/*\n * Copyright 2013 The Polymer Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style\n * license that can be found in the LICENSE file.\n */\n(function(scope) {\n\n  var api = {};\n\n  api.declaration = {};\n  api.instance = {};\n\n  // exports\n\n  scope.api = api;\n\n})(Polymer);\n","/*\n * Copyright 2013 The Polymer Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style\n * license that can be found in the LICENSE file.\n */\n(function(scope) {\n\n  var utils = {\n    /**\n      * Invokes a function asynchronously. The context of the callback\n      * function is bound to 'this' automatically.\n      * @method async\n      * @param {Function|String} method\n      * @param {any|Array} args\n      * @param {number} timeout\n      */\n    async: function(method, args, timeout) {\n      // when polyfilling Object.observe, ensure changes \n      // propagate before executing the async method\n      Platform.flush();\n      // second argument to `apply` must be an array\n      args = (args && args.length) ? args : [args];\n      // function to invoke\n      var fn = function() {\n        (this[method] || method).apply(this, args);\n      }.bind(this);\n      // execute `fn` sooner or later\n      return timeout ? setTimeout(fn, timeout) : requestAnimationFrame(fn);\n    },\n    /**\n      * Fire an event.\n      * @method fire\n      * @returns {Object} event\n      * @param {string} type An event name.\n      * @param {any} detail\n      * @param {Node} onNode Target node.\n      */\n    fire: function(type, detail, onNode, bubbles, cancelable) {\n      var node = onNode || this;\n      var detail = detail || {};\n      var event = new CustomEvent(type, {\n        bubbles: (bubbles !== undefined ? bubbles : true), \n        cancelable: (cancelable !== undefined ? cancelable : true), \n        detail: detail\n      });\n      node.dispatchEvent(event);\n      return event;\n    },\n    /**\n      * Fire an event asynchronously.\n      * @method asyncFire\n      * @param {string} type An event name.\n      * @param detail\n      * @param {Node} toNode Target node.\n      */\n    asyncFire: function(/*inType, inDetail*/) {\n      this.async(\"fire\", arguments);\n    },\n    /**\n      * Remove class from old, add class to anew, if they exist\n      * @param classFollows\n      * @param anew A node.\n      * @param old A node\n      * @param className\n      */\n    classFollows: function(anew, old, className) {\n      if (old) {\n        old.classList.remove(className);\n      }\n      if (anew) {\n        anew.classList.add(className);\n      }\n    }\n  };\n\n  // no-operation function for handy stubs\n  var nop = function() {};\n  // null-object for handy stubs\n  var nob = {};\n\n  // deprecated\n\n  utils.asyncMethod = utils.async;\n\n  // exports\n\n  scope.api.instance.utils = utils;\n  scope.nop = nop;\n  scope.nob = nob;\n\n})(Polymer);\n","/*\n * Copyright 2013 The Polymer Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style\n * license that can be found in the LICENSE file.\n */\n\n(function(scope) {\n\n  // imports\n\n  var log = window.logFlags || {};\n\n  // magic words\n\n  var EVENT_PREFIX = 'on-';\n  var HANDLED_LIST = '__eventHandledList__';\n\n  // instance events api\n\n  var events = {\n    // read-only\n    EVENT_PREFIX: EVENT_PREFIX,\n    // event name utilities\n    hasEventPrefix: function (n) {\n      return n && (n[0] === 'o') && (n[1] === 'n') && (n[2] === '-');\n    },\n    removeEventPrefix: function(n) {\n      return n.slice(prefixLength);\n    },\n    // event listeners on host\n    addHostListeners: function() {\n      var events = this.eventDelegates;\n      log.events && (Object.keys(events).length > 0) && console.log('[%s] addHostListeners:', this.localName, events);\n      this.addNodeListeners(this, events, this.hostEventListener);\n    },\n    addNodeListeners: function(node, events, listener) {\n      // note: conditional inside loop as optimization\n      // for empty 'events' object\n      var fn;\n      for (var n in events) {\n        if (!fn) {\n          fn = listener.bind(this);\n        }\n        this.addNodeListener(node, n, fn);\n      }\n    },\n    addNodeListener: function(node, event, listener) {\n      node.addEventListener(event, listener);\n    },\n    hostEventListener: function(event) {\n      if (!event.cancelBubble) {\n        log.events && console.group(\"[%s]: hostEventListener(%s)\", this.localName, event.type);\n        var h = this.findEventDelegate(event);\n        if (h) {\n          log.events && console.log('[%s] found host handler name [%s]', this.localName, h);\n          this.dispatchMethod(this, h, [event, event.detail, this]);\n        }\n        log.events && console.groupEnd();\n      }\n    },  \n    // find the method name in delegates mapped to event.type\n    findEventDelegate: function(event) {\n      return this.eventDelegates[event.type];\n    },\n    // call 'method' or function method on 'obj' with 'args', if the method exists\n    dispatchMethod: function(obj, method, args) {\n      if (obj) {\n        log.events && console.group('[%s] dispatch [%s]', obj.localName, method);\n        var fn = typeof method === 'function' ? method : obj[method];\n        if (fn) {\n          fn[args ? 'apply' : 'call'](obj, args);\n        }\n        log.events && console.groupEnd();\n        Platform.flush();\n      }\n    },\n    //\n    //  Bind events via attributes of the form on-eventName.\n    //  This method hooks into the model syntax and does adds event listeners as\n    //  needed. By default, binding paths are always method names on the root\n    //  model, the custom element in which the node exists. Adding a '@' in the\n    //  path directs the event binding to use the model path as the event listener.\n    //  In both cases, the actual listener is attached to a generic method which\n    //  evaluates the bound path at event execution time. \n    //\n    prepareBinding: function(path, name, node) {\n      // if lhs an event prefix,\n      if (events.hasEventPrefix(name)) {\n        // provide an event-binding callback\n        return function(model, node) {\n          log.events && console.log('event: [%s].%s => [%s].%s()\"', node.localName, model.localName, path);\n          var listener = function(event) {\n            var ctrlr = findController(node);\n            if (ctrlr && ctrlr.dispatchMethod) {\n              var obj = ctrlr, method = path;\n              if (path[0] == '@') {\n                obj = model;\n                method = Path.get(path.slice(1)).getValueFrom(model);\n              }\n              ctrlr.dispatchMethod(obj, method, [event, event.detail, node]);\n            }\n          };\n          var eventName = events.removeEventPrefix(name);\n          return {\n            open: function() {\n              node.addEventListener(eventName, listener, false);\n            },\n            close: function() {\n              log.events && console.log('event.remove: [%s].%s => [%s].%s()\"', node.localName, name, model.localName, path);\n              node.removeEventListener(eventName, listener, false);\n            },\n            discardChanges: function() {}\n          }\n        };\n      }\n    }\n  };\n\n  var prefixLength = EVENT_PREFIX.length;\n\n  function findController(node) {\n    while (node.parentNode) {\n      node = node.parentNode;\n    }\n    return node.host;\n  };\n\n  // exports\n\n  scope.api.instance.events = events;\n\n})(Polymer);\n","/*\r\n * Copyright 2013 The Polymer Authors. All rights reserved.\r\n * Use of this source code is governed by a BSD-style\r\n * license that can be found in the LICENSE file.\r\n */\r\n(function(scope) {\r\n\r\n  // instance api for attributes\r\n\r\n  var attributes = {\r\n    copyInstanceAttributes: function () {\r\n      var a$ = this._instanceAttributes;\r\n      for (var k in a$) {\r\n        if (!this.hasAttribute(k)) {\r\n          this.setAttribute(k, a$[k]);\r\n        }\r\n      }\r\n    },\r\n    // for each attribute on this, deserialize value to property as needed\r\n    takeAttributes: function() {\r\n      // if we have no publish lookup table, we have no attributes to take\r\n      // TODO(sjmiles): ad hoc\r\n      if (this._publishLC) {\r\n        for (var i=0, a$=this.attributes, l=a$.length, a; (a=a$[i]) && i<l; i++) {\r\n          this.attributeToProperty(a.name, a.value);\r\n        }\r\n      }\r\n    },\r\n    // if attribute 'name' is mapped to a property, deserialize\r\n    // 'value' into that property\r\n    attributeToProperty: function(name, value) {\r\n      // try to match this attribute to a property (attributes are\r\n      // all lower-case, so this is case-insensitive search)\r\n      var name = this.propertyForAttribute(name);\r\n      if (name) {\r\n        // filter out 'mustached' values, these are to be\r\n        // replaced with bound-data and are not yet values\r\n        // themselves\r\n        if (value && value.search(scope.bindPattern) >= 0) {\r\n          return;\r\n        }\r\n        // get original value\r\n        var currentValue = this[name];\r\n        // deserialize Boolean or Number values from attribute\r\n        var value = this.deserializeValue(value, currentValue);\r\n        // only act if the value has changed\r\n        if (value !== currentValue) {\r\n          // install new value (has side-effects)\r\n          this[name] = value;\r\n        }\r\n      }\r\n    },\r\n    // return the published property matching name, or undefined\r\n    propertyForAttribute: function(name) {\r\n      var match = this._publishLC && this._publishLC[name];\r\n      //console.log('propertyForAttribute:', name, 'matches', match);\r\n      return match;\r\n    },\r\n    // convert representation of 'stringValue' based on type of 'currentValue'\r\n    deserializeValue: function(stringValue, currentValue) {\r\n      return scope.deserializeValue(stringValue, currentValue);\r\n    },\r\n    serializeValue: function(value, inferredType) {\r\n      if (inferredType === 'boolean') {\r\n        return value ? '' : undefined;\r\n      } else if (inferredType !== 'object' && inferredType !== 'function'\r\n          && value !== undefined) {\r\n        return value;\r\n      }\r\n    },\r\n    reflectPropertyToAttribute: function(name) {\r\n      var inferredType = typeof this[name];\r\n      // try to intelligently serialize property value\r\n      var serializedValue = this.serializeValue(this[name], inferredType);\r\n      // boolean properties must reflect as boolean attributes\r\n      if (serializedValue !== undefined) {\r\n        this.setAttribute(name, serializedValue);\r\n        // TODO(sorvell): we should remove attr for all properties\r\n        // that have undefined serialization; however, we will need to\r\n        // refine the attr reflection system to achieve this; pica, for example,\r\n        // relies on having inferredType object properties not removed as\r\n        // attrs.\r\n      } else if (inferredType === 'boolean') {\r\n        this.removeAttribute(name);\r\n      }\r\n    }\r\n  };\r\n\r\n  // exports\r\n\r\n  scope.api.instance.attributes = attributes;\r\n\r\n})(Polymer);\r\n","/*\n * Copyright 2013 The Polymer Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style\n * license that can be found in the LICENSE file.\n */\n(function(scope) {\n\n  // imports\n\n  var log = window.logFlags || {};\n\n  // magic words\n\n  var OBSERVE_SUFFIX = 'Changed';\n\n  // element api\n\n  var empty = [];\n\n  var properties = {\n    observeProperties: function() {\n      var n$ = this._observeNames, pn$ = this._publishNames;\n      if ((n$ && n$.length) || (pn$ && pn$.length)) {\n        var self = this;\n        var o = this._propertyObserver = new CompoundObserver();\n        for (var i=0, l=n$.length, n; (i<l) && (n=n$[i]); i++) {\n          o.addPath(this, n);\n          // observer array properties\n          var pd = Object.getOwnPropertyDescriptor(this.__proto__, n);\n          if (pd && pd.value) {\n            this.observeArrayValue(n, pd.value, null);\n          }\n        }\n        for (var i=0, l=pn$.length, n; (i<l) && (n=pn$[i]); i++) {\n          if (!this.observe || (this.observe[n] === undefined)) {\n            o.addPath(this, n);\n          }\n        }\n        o.open(this.notifyPropertyChanges, this);\n      }\n    },\n    notifyPropertyChanges: function(newValues, oldValues, paths) {\n      var name, method, called = {};\n      for (var i in oldValues) {\n        // note: paths is of form [object, path, object, path]\n        name = paths[2 * i + 1];\n        if (this.publish[name] !== undefined) {\n          this.reflectPropertyToAttribute(name);\n        }\n        method = this.observe[name];\n        if (method) {\n          this.observeArrayValue(name, newValues[i], oldValues[i]);\n          if (!called[method]) {\n            called[method] = true;\n            // observes the value if it is an array\n            this.invokeMethod(method, [oldValues[i], newValues[i], arguments]);\n          }\n        }\n      }\n    },\n    observeArrayValue: function(name, value, old) {\n      // we only care if there are registered side-effects\n      var callbackName = this.observe[name];\n      if (callbackName) {\n        // if we are observing the previous value, stop\n        if (Array.isArray(old)) {\n          log.observe && console.log('[%s] observeArrayValue: unregister observer [%s]', this.localName, name);\n          this.unregisterObserver(name + '__array');\n        }\n        // if the new value is an array, being observing it\n        if (Array.isArray(value)) {\n          log.observe && console.log('[%s] observeArrayValue: register observer [%s]', this.localName, name, value);\n          var observer = new ArrayObserver(value);\n          observer.open(function(value, old) {\n            this.invokeMethod(callbackName, [old]);\n          }, this);\n          this.registerObserver(name + '__array', observer);\n        }\n      }\n    },\n    bindProperty: function(property, observable) {\n      // apply Polymer two-way reference binding\n      return bindProperties(this, property, observable);\n    },\n    unbindAllProperties: function() {\n      if (this._propertyObserver) {\n        this._propertyObserver.close();\n      }\n      this.unregisterObservers();\n    },\n    unbindProperty: function(name) {\n      return this.unregisterObserver(name);\n    },\n    invokeMethod: function(method, args) {\n      var fn = this[method] || method;\n      if (typeof fn === 'function') {\n        fn.apply(this, args);\n      }\n    },\n    // bookkeeping observers for memory management\n    registerObserver: function(name, observer) {\n      var o$ = this._observers || (this._observers = {});\n      o$[name] = observer;\n    },\n    unregisterObserver: function(name) {\n      var o$ = this._observers;\n      if (o$ && o$[name]) {\n        o$[name].close();\n        o$[name] = null;\n        return true;\n      }\n    },\n    unregisterObservers: function() {\n      if (this._observers) {\n        var keys=Object.keys(this._observers);\n        for (var i=0, l=keys.length, k, o; (i < l) && (k=keys[i]); i++) {\n          o = this._observers[k];\n          o.close();\n        }\n        this._observers = {};\n      }\n    }\n  };\n\n  // property binding\n  // bind a property in A to a path in B by converting A[property] to a\n  // getter/setter pair that accesses B[...path...]\n  function bindProperties(inA, inProperty, observable) {\n    log.bind && console.log(LOG_BIND_PROPS, inB.localName || 'object', inPath, inA.localName, inProperty);\n    // capture A's value if B's value is null or undefined,\n    // otherwise use B's value\n    // TODO(sorvell): need to review, can do with ObserverTransform\n    var v = observable.discardChanges();\n    if (v === null || v === undefined) {\n      observable.setValue(inA[inProperty]);\n    }\n    return Observer.defineComputedProperty(inA, inProperty, observable);\n  }\n\n  // logging\n  var LOG_OBSERVE = '[%s] watching [%s]';\n  var LOG_OBSERVED = '[%s#%s] watch: [%s] now [%s] was [%s]';\n  var LOG_CHANGED = '[%s#%s] propertyChanged: [%s] now [%s] was [%s]';\n  var LOG_BIND_PROPS = \"[%s]: bindProperties: [%s] to [%s].[%s]\";\n\n  // exports\n\n  scope.api.instance.properties = properties;\n\n})(Polymer);\n","/*\n * Copyright 2013 The Polymer Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style\n * license that can be found in the LICENSE file.\n */\n(function(scope) {\n\n  // imports\n\n  var log = window.logFlags || 0;\n  var events = scope.api.instance.events;\n\n  // expressionista\n\n  // TODO(sorvell): we're patching the syntax while evaluating\n  // event bindings. we'll move this to a better spot when that's done.\n  var _prepareBinding = PolymerExpressions.prototype.prepareBinding;\n  // <[node] [name] = {{path}}>\n  PolymerExpressions.prototype.prepareBinding = function(path, name, node) {\n    // if not an event, delegate to the standard syntax\n    return events.prepareBinding(path, name, node)\n        || _prepareBinding.call(this, path, name, node);\n  };\n\n  var syntax = new PolymerExpressions();\n\n  // element api supporting mdv\n\n  var mdv = {\n    syntax: syntax,\n    instanceTemplate: function(template) {\n      return template.createInstance(this, this.syntax);\n    },\n    bind: function(name, observable) {\n      // note: binding is a prepare signal. This allows us to be sure that any\n      // property changes that occur as a result of binding will be observed.\n      if (!this._elementPrepared) {\n        this.prepareElement();\n      }\n      var property = this.propertyForAttribute(name);\n      if (!property) {\n        // TODO(sjmiles): this mixin method must use the special form\n        // of `super` installed by `mixinMethod` in declaration/prototype.js\n        return this.mixinSuper(arguments);\n      } else {\n        // clean out the closets\n        this.unbind(name);\n        // use n-way Polymer binding\n        var observer = this.bindProperty(property, observable);\n        // stick path on observer so it's available via this.bindings\n        observer.path = observable.path_;\n        // reflect bound property to attribute when binding\n        // to ensure binding is not left on attribute if property\n        // does not update due to not changing.\n        this.reflectPropertyToAttribute(property);\n        return this.bindings[name] = observer;\n      }\n    },\n    asyncUnbindAll: function() {\n      if (!this._unbound) {\n        log.unbind && console.log('[%s] asyncUnbindAll', this.localName);\n        this._unbindAllJob = this.job(this._unbindAllJob, this.unbindAll, 0);\n      }\n    },\n    unbindAll: function() {\n      if (!this._unbound) {\n        this.unbindAllProperties();\n        this.super();\n        // unbind shadowRoot\n        var root = this.shadowRoot;\n        while (root) {\n          unbindNodeTree(root);\n          root = root.olderShadowRoot;\n        }\n        this._unbound = true;\n      }\n    },\n    cancelUnbindAll: function(preventCascade) {\n      if (this._unbound) {\n        log.unbind && console.warn('[%s] already unbound, cannot cancel unbindAll', this.localName);\n        return;\n      }\n      log.unbind && console.log('[%s] cancelUnbindAll', this.localName);\n      if (this._unbindAllJob) {\n        this._unbindAllJob = this._unbindAllJob.stop();\n      }\n      // cancel unbinding our shadow tree iff we're not in the process of\n      // cascading our tree (as we do, for example, when the element is inserted).\n      if (!preventCascade) {\n        forNodeTree(this.shadowRoot, function(n) {\n          if (n.cancelUnbindAll) {\n            n.cancelUnbindAll();\n          }\n        });\n      }\n    }\n  };\n\n  function unbindNodeTree(node) {\n    forNodeTree(node, _nodeUnbindAll);\n  }\n\n  function _nodeUnbindAll(node) {\n    node.unbindAll();\n  }\n\n  function forNodeTree(node, callback) {\n    if (node) {\n      callback(node);\n      for (var child = node.firstChild; child; child = child.nextSibling) {\n        forNodeTree(child, callback);\n      }\n    }\n  }\n\n  var mustachePattern = /\\{\\{([^{}]*)}}/;\n\n  // exports\n\n  scope.bindPattern = mustachePattern;\n  scope.api.instance.mdv = mdv;\n\n})(Polymer);\n","/*\n * Copyright 2013 The Polymer Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style\n * license that can be found in the LICENSE file.\n */\n(function(scope) {\n  var preparingElements = 0;\n\n  var base = {\n    PolymerBase: true,\n    job: Polymer.job,\n    super: Polymer.super,\n    // user entry point for element has had its createdCallback called\n    created: function() {\n    },\n    // user entry point for element has shadowRoot and is ready for\n    // api interaction\n    ready: function() {\n    },\n    createdCallback: function() {\n      this.created();\n      if (this.ownerDocument.defaultView || this.alwaysPrepare ||\n          preparingElements > 0) {\n        this.prepareElement();\n      }\n    },\n    // system entry point, do not override\n    prepareElement: function() {\n      this._elementPrepared = true;\n      // install property observers\n      this.observeProperties();\n      // install boilerplate attributes\n      this.copyInstanceAttributes();\n      // process input attributes\n      this.takeAttributes();\n      // add event listeners\n      this.addHostListeners();\n      // guarantees that while preparing, any\n      // sub-elements are also prepared\n      preparingElements++;\n      // process declarative resources\n      this.parseDeclarations(this.__proto__);\n      // decrement semaphore\n      preparingElements--;\n      // user entry point\n      this.ready();\n    },\n    attachedCallback: function() {\n      if (!this._elementPrepared) {\n        this.prepareElement();\n      }\n      this.cancelUnbindAll(true);\n      // invoke user action\n      if (this.attached) {\n        this.attached();\n      }\n      // TODO(sorvell): bc\n      if (this.enteredView) {\n        this.enteredView();\n      }\n    },\n    detachedCallback: function() {\n      if (!this.preventDispose) {\n        this.asyncUnbindAll();\n      }\n      // invoke user action\n      if (this.detached) {\n        this.detached();\n      }\n      // TODO(sorvell): bc\n      if (this.leftView) {\n        this.leftView();\n      }\n    },\n    // TODO(sorvell): bc\n    enteredViewCallback: function() {\n      this.attachedCallback();\n    },\n    // TODO(sorvell): bc\n    leftViewCallback: function() {\n      this.detachedCallback();\n    },\n    // TODO(sorvell): bc\n    enteredDocumentCallback: function() {\n      this.attachedCallback();\n    },\n    // TODO(sorvell): bc\n    leftDocumentCallback: function() {\n      this.detachedCallback();\n    },\n    // recursive ancestral <element> initialization, oldest first\n    parseDeclarations: function(p) {\n      if (p && p.element) {\n        this.parseDeclarations(p.__proto__);\n        p.parseDeclaration.call(this, p.element);\n      }\n    },\n    // parse input <element> as needed, override for custom behavior\n    parseDeclaration: function(elementElement) {\n      var template = this.fetchTemplate(elementElement);\n      if (template) {\n        if (this.element.hasAttribute('lightdom')) {\n          this.lightFromTemplate(template);\n        } else {\n          this.shadowFromTemplate(template);\n        }\n      }\n    },\n    // return a shadow-root template (if desired), override for custom behavior\n    fetchTemplate: function(elementElement) {\n      return elementElement.querySelector('template');\n    },\n    // utility function that creates a shadow root from a <template>\n    shadowFromTemplate: function(template) {\n      if (template) {\n        // cache elder shadow root (if any)\n        var elderRoot = this.shadowRoot;\n        // make a shadow root\n        var root = this.createShadowRoot();\n        // migrate flag(s)\n        root.resetStyleInheritance = this.resetStyleInheritance;\n        // stamp template\n        // which includes parsing and applying MDV bindings before being \n        // inserted (to avoid {{}} in attribute values)\n        // e.g. to prevent <img src=\"images/{{icon}}\"> from generating a 404.\n        var dom = this.instanceTemplate(template);\n        // append to shadow dom\n        root.appendChild(dom);\n        // perform post-construction initialization tasks on shadow root\n        this.shadowRootReady(root, template);\n        // return the created shadow root\n        return root;\n      }\n    },\n    // utility function that stamps a <template> into light-dom\n    lightFromTemplate: function(template) {\n      if (template) {\n        // stamp template\n        // which includes parsing and applying MDV bindings before being \n        // inserted (to avoid {{}} in attribute values)\n        // e.g. to prevent <img src=\"images/{{icon}}\"> from generating a 404.\n        var dom = this.instanceTemplate(template);\n        // append to shadow dom\n        this.appendChild(dom);\n        // perform post-construction initialization tasks on ahem, light root\n        this.shadowRootReady(this, template);\n        // return the created shadow root\n        return dom;\n      }\n    },\n    shadowRootReady: function(root, template) {\n      // locate nodes with id and store references to them in this.$ hash\n      this.marshalNodeReferences(root);\n      // set up pointer gestures\n      PointerGestures.register(root);\n    },\n    // locate nodes with id and store references to them in this.$ hash\n    marshalNodeReferences: function(root) {\n      // establish $ instance variable\n      var $ = this.$ = this.$ || {};\n      // populate $ from nodes with ID from the LOCAL tree\n      if (root) {\n        var n$ = root.querySelectorAll(\"[id]\");\n        for (var i=0, l=n$.length, n; (i<l) && (n=n$[i]); i++) {\n          $[n.id] = n;\n        };\n      }\n    },\n    attributeChangedCallback: function(name, oldValue) {\n      // TODO(sjmiles): adhoc filter\n      if (name !== 'class' && name !== 'style') {\n        this.attributeToProperty(name, this.getAttribute(name));\n      }\n      if (this.attributeChanged) {\n        this.attributeChanged.apply(this, arguments);\n      }\n    },\n    onMutation: function(node, listener) {\n      var observer = new MutationObserver(function(mutations) {\n        listener.call(this, observer, mutations);\n        observer.disconnect();\n      }.bind(this));\n      observer.observe(node, {childList: true, subtree: true});\n    }\n  };\n\n  // true if object has own PolymerBase api\n  function isBase(object) {\n    return object.hasOwnProperty('PolymerBase') \n  }\n\n  // name a base constructor for dev tools\n\n  function PolymerBase() {};\n  PolymerBase.prototype = base;\n  base.constructor = PolymerBase;\n  \n  // exports\n\n  scope.Base = PolymerBase;\n  scope.isBase = isBase;\n  scope.api.instance.base = base;\n  \n})(Polymer);\n","/*\n * Copyright 2013 The Polymer Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style\n * license that can be found in the LICENSE file.\n */\n(function(scope) {\n\n  // imports\n\n  var log = window.logFlags || {};\n  \n  // magic words\n  \n  var STYLE_SCOPE_ATTRIBUTE = 'element';\n  var STYLE_CONTROLLER_SCOPE = 'controller';\n  \n  var styles = {\n    STYLE_SCOPE_ATTRIBUTE: STYLE_SCOPE_ATTRIBUTE,\n    /**\n     * Installs external stylesheets and <style> elements with the attribute \n     * polymer-scope='controller' into the scope of element. This is intended\n     * to be a called during custom element construction. Note, this incurs a \n     * per instance cost and should be used sparingly.\n     *\n     * The need for this type of styling should go away when the shadowDOM spec\n     * addresses these issues:\n     * \n     * https://www.w3.org/Bugs/Public/show_bug.cgi?id=21391\n     * https://www.w3.org/Bugs/Public/show_bug.cgi?id=21390\n     * https://www.w3.org/Bugs/Public/show_bug.cgi?id=21389\n     * \n     * @param element The custom element instance into whose controller (parent)\n     * scope styles will be installed.\n     * @param elementElement The <element> containing controller styles.\n    */\n    // TODO(sorvell): remove when spec issues are addressed\n    installControllerStyles: function() {\n      // apply controller styles, but only if they are not yet applied\n      var scope = this.findStyleController();\n      if (scope && !this.scopeHasElementStyle(scope, STYLE_CONTROLLER_SCOPE)) {\n        // allow inherited controller styles\n        var proto = getPrototypeOf(this), cssText = '';\n        while (proto && proto.element) {\n          cssText += proto.element.cssTextForScope(STYLE_CONTROLLER_SCOPE);\n          proto = getPrototypeOf(proto);\n        }\n        if (cssText) {\n          var style = this.element.cssTextToScopeStyle(cssText,\n              STYLE_CONTROLLER_SCOPE);\n          // TODO(sorvell): for now these styles are not shimmed\n          // but we may need to shim them\n          Polymer.applyStyleToScope(style, scope);\n        }\n      }\n    },\n    findStyleController: function() {\n      if (window.ShadowDOMPolyfill) {\n        return wrap(document.head);\n      } else {\n        // find the shadow root that contains this element\n        var n = this;\n        while (n.parentNode) {\n          n = n.parentNode;\n        }\n        return n === document ? document.head : n;\n      }\n    },\n    scopeHasElementStyle: function(scope, descriptor) {\n      var rule = STYLE_SCOPE_ATTRIBUTE + '=' + this.localName + '-' + descriptor;\n      return scope.querySelector('style[' + rule + ']');\n    }\n  };\n  \n  // NOTE: use raw prototype traversal so that we ensure correct traversal\n  // on platforms where the protoype chain is simulated via __proto__ (IE10)\n  function getPrototypeOf(prototype) {\n    return prototype.__proto__;\n  }\n\n  // exports\n\n  scope.api.instance.styles = styles;\n  \n})(Polymer);\n","/* \n * Copyright 2013 The Polymer Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style\n * license that can be found in the LICENSE file.\n */\n\n(function(scope) {\n\nvar path = {\n  resolveElementPaths: function(node) {\n    pathResolver.resolvePathsInHTML(node);\n  },\n  addResolvePathApi: function() {\n    var root = this.elementPath();\n    // let assetpath attribute modify the resolve path\n    var assetPath = this.getAttribute('assetpath') || '';\n    var relPath = this.relPath;\n    this.prototype.resolvePath = function(inPath, base) {\n      if (base) {\n        return this.element.urlToPath(base) + inPath;\n      }\n      var to = inPath;\n      if (assetPath) {\n        // assetPath is always a folder, drop the trailing '/'\n        var from = assetPath.slice(0, -1);\n        to = relPath(from, to);\n      }\n      return root + assetPath + to;\n    };\n  },\n  elementPath: function() {\n    return this.urlToPath(pathResolver.getDocumentUrl(this.ownerDocument));\n  },\n  relPath: function(from, to) {\n    var fromParts = from.split('/');\n    var toParts = to.split('/');\n\n    // chop to common length\n    var common = false;\n    while(fromParts.length && toParts.length && fromParts[0] === toParts[0]) {\n      fromParts.shift();\n      toParts.shift();\n      common = true;\n    }\n\n    // if there were some commonalities, add '../' for differences\n    if (common) {\n      for (var i = 0; i < fromParts.length; i++) {\n        toParts.unshift('..');\n      }\n    }\n    return toParts.join('/');\n  },\n  urlToPath: function(url) {\n    if (!url) {\n      return '';\n    } else {\n      var parts = url.split('/');\n      parts.pop();\n      parts.push('');\n      return parts.join('/');\n    }\n  }\n};\n\nvar URL_ATTRS = ['href', 'src', 'action'];\nvar URL_ATTRS_SELECTOR = '[' + URL_ATTRS.join('],[') + ']';\nvar URL_TEMPLATE_SEARCH = '{{.*}}';\nvar CSS_URL_REGEXP = /(url\\()([^)]*)(\\))/g;\nvar CSS_IMPORT_REGEXP = /(@import[\\s]*)([^;]*)(;)/g;\n\nvar pathResolver = {\n  nodeUrl: function(node) {\n    var docUrl = path.documentUrlFromNode(node);\n    return pathResolver.resolveUrl(docUrl, path.hrefOrSrc(node));\n    //return path.resolveUrl(path.documentURL, path.hrefOrSrc(node));\n  },\n  hrefOrSrc: function(node) {\n    return node.getAttribute(\"href\") || node.getAttribute(\"src\");\n  },\n  documentUrlFromNode: function(node) {\n    return pathResolver.getDocumentUrl(node.ownerDocument || node);\n  },\n  getDocumentUrl: function(doc) {\n    var url = doc &&\n        // TODO(sjmiles): ShadowDOMPolyfill intrusion\n        (doc._URL || (doc.impl && doc.impl._URL)\n            || doc.baseURI || doc.URL)\n                || '';\n    // take only the left side if there is a #\n    return url.split('#')[0];\n  },\n  resolveUrl: function(baseUrl, url) {\n    if (this.isAbsUrl(url)) {\n      return url;\n    }\n    return this.compressUrl(this.urlToPath(baseUrl) + url);\n  },\n  resolveRelativeUrl: function(baseUrl, url) {\n    if (this.isAbsUrl(url)) {\n      return url;\n    }\n    return this.makeDocumentRelPath(this.resolveUrl(baseUrl, url));\n  },\n  isAbsUrl: function(url) {\n    return /(^data:)|(^http[s]?:)|(^\\/)/.test(url);\n  },\n  urlToPath: function(baseUrl) {\n    var parts = baseUrl.split(\"/\");\n    parts.pop();\n    parts.push('');\n    return parts.join(\"/\");\n  },\n  compressUrl: function(url) {\n    var search = '';\n    var searchPos = url.indexOf('?');\n    // query string is not part of the path\n    if (searchPos > -1) {\n      search = url.substring(searchPos);\n      url = url.substring(searchPos, 0);\n    }\n    var parts = url.split('/');\n    for (var i=0, p; i<parts.length; i++) {\n      p = parts[i];\n      if (p === '..') {\n        parts.splice(i-1, 2);\n        i -= 2;\n      }\n    }\n    return parts.join('/') + search;\n  },\n  makeDocumentRelPath: function(url) {\n    // test url against document to see if we can construct a relative path\n    pathResolver.urlElt.href = url;\n    // IE does not set host if same as document\n    if (!pathResolver.urlElt.host ||\n        (!window.location.port && pathResolver.urlElt.port === '80') || \n        (pathResolver.urlElt.hostname === window.location.hostname &&\n        pathResolver.urlElt.port === window.location.port &&\n        pathResolver.urlElt.protocol === window.location.protocol)) {\n      return this.makeRelPath(pathResolver.documentURL, pathResolver.urlElt.href);\n    } else {\n      return url;\n    }\n  },\n  // make a relative path from source to target\n  makeRelPath: function(source, target) {\n    var s = source.split('/');\n    var t = target.split('/');\n    while (s.length && s[0] === t[0]){\n      s.shift();\n      t.shift();\n    }\n    for(var i = 0, l = s.length-1; i < l; i++) {\n      t.unshift('..');\n    }\n    var r = t.join('/');\n    return r;\n  },\n  makeAbsUrl: function(url) {\n    pathResolver.urlElt.href = url;\n    return pathResolver.urlElt.href;\n  },\n  resolvePathsInHTML: function(root, url) {\n    url = url || pathResolver.documentUrlFromNode(root);\n    if (root.hasAttributes && root.hasAttributes()) {\n      pathResolver.resolveNodeAttributes(root, url);\n    }\n    pathResolver.resolveAttributes(root, url);\n    pathResolver.resolveStyleElts(root, url);\n    // handle template.content\n    var templates = root.querySelectorAll('template');\n    if (templates) {\n      for (var i=0, l=templates.length, t; (i<l) && (t=templates[i]); i++) {\n        if (t.content) {\n          pathResolver.resolvePathsInHTML(t.content, url);\n        }\n      }\n    }\n  },\n  resolvePathsInStylesheet: function(sheet) {\n    var docUrl = pathResolver.nodeUrl(sheet);\n    sheet.__resource = pathResolver.resolveCssText(sheet.__resource, docUrl);\n  },\n  resolveStyleElts: function(root, url) {\n    var styles = root.querySelectorAll('style');\n    if (styles) {\n      for (var i=0, l=styles.length, s; (i<l) && (s=styles[i]); i++) {  \n        pathResolver.resolveStyleElt(s, url);\n      }\n    }\n  },\n  resolveStyleElt: function(style, url) {\n    url = url || pathResolver.documentUrlFromNode(style);\n    style.textContent = pathResolver.resolveCssText(style.textContent, url);\n  },\n  resolveCssText: function(cssText, baseUrl) {\n    var cssText = pathResolver.replaceUrlsInCssText(cssText, baseUrl, CSS_URL_REGEXP);\n    return pathResolver.replaceUrlsInCssText(cssText, baseUrl, CSS_IMPORT_REGEXP);\n  },\n  replaceUrlsInCssText: function(cssText, baseUrl, regexp) {\n    return cssText.replace(regexp, function(m, pre, url, post) {\n      var urlPath = url.replace(/[\"']/g, '');\n      urlPath = pathResolver.resolveRelativeUrl(baseUrl, urlPath);\n      return pre + '\\'' + urlPath + '\\'' + post;\n    });\n  },\n  resolveAttributes: function(root, url) {\n    // search for attributes that host urls\n    var nodes = root && root.querySelectorAll(URL_ATTRS_SELECTOR);\n    if (nodes) {\n      for (var i=0, l=nodes.length, n; (i<l) && (n=nodes[i]); i++) {  \n        this.resolveNodeAttributes(n, url);\n      }\n    }\n  },\n  resolveNodeAttributes: function(node, url) {\n    url = url || pathResolver.documentUrlFromNode(node);\n    URL_ATTRS.forEach(function(v) {\n      var attr = node.attributes[v];\n      if (attr && attr.value &&\n         (attr.value.search(URL_TEMPLATE_SEARCH) < 0)) {\n        var urlPath = pathResolver.resolveRelativeUrl(url, attr.value);\n        attr.value = urlPath;\n      }\n    });\n  }\n};\n\npathResolver.documentURL = pathResolver.getDocumentUrl(document);\npathResolver.urlElt = document.createElement('a');\n\n// exports\nscope.api.declaration.path = path;\nscope.pathResolver = pathResolver;\n\n})(Polymer);\n","/*\n * Copyright 2013 The Polymer Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style\n * license that can be found in the LICENSE file.\n */\n(function(scope) {\n\n  // imports\n\n  var log = window.logFlags || {};\n  var api = scope.api.instance.styles;\n  var STYLE_SCOPE_ATTRIBUTE = api.STYLE_SCOPE_ATTRIBUTE;\n\n  // magic words\n\n  var STYLE_SELECTOR = 'style';\n  var STYLE_LOADABLE_MATCH = '@import';\n  var SHEET_SELECTOR = 'link[rel=stylesheet]';\n  var STYLE_GLOBAL_SCOPE = 'global';\n  var SCOPE_ATTR = 'polymer-scope';\n\n  var styles = {\n    // returns true if resources are loading\n    loadStyles: function(callback) {\n      var content = this.templateContent();\n      if (content) {\n        this.convertSheetsToStyles(content);\n      }\n      var styles = this.findLoadableStyles(content);\n      if (styles.length) {\n        // if SD polyfill or opt-in, use xhr for cssText, otherwise\n        // allow platform to cache styles.\n        // TODO(sorvell): experimental flag to force direct caching of cssTest\n        // rather than relying on platform to cache @import rules.\n        if (window.ShadowDOMPolyfill || this.hasAttribute('cache-csstext')) {\n          Platform.loader.xhrStyles(styles, callback);\n        } else {\n          Platform.loader.cacheStyles(styles, callback);\n        }\n      } else if (callback) {\n        callback();\n      }\n    },\n    convertSheetsToStyles: function(root) {\n      var s$ = root.querySelectorAll(SHEET_SELECTOR);\n      for (var i=0, l=s$.length, s, c; (i<l) && (s=s$[i]); i++) {\n        c = createStyleElement(importRuleForSheet(s), s.ownerDocument);\n        var scope = s.getAttribute(SCOPE_ATTR);\n        if (scope) {\n          c.setAttribute(SCOPE_ATTR, scope);\n        }\n        s.parentNode.replaceChild(c, s);\n      }\n    },\n    findLoadableStyles: function(root) {\n      var loadables = [];\n      if (root) {\n        var s$ = root.querySelectorAll(STYLE_SELECTOR);\n        for (var i=0, l=s$.length, s; (i<l) && (s=s$[i]); i++) {\n          if (s.textContent.match(STYLE_LOADABLE_MATCH)) {\n            loadables.push(s);\n          }\n        }\n      }\n      return loadables;\n    },\n    /**\n     * Install external stylesheets loaded in <polymer-element> elements into the \n     * element's template.\n     * @param elementElement The <element> element to style.\n     */\n    // TODO(sorvell): wip... caching and styles handling can probably be removed\n    // We need a scheme to ensure stylesheets are eagerly loaded without \n    // the creation of an element instance. Here are 2 options for handling this:\n    // 1. create a dummy element with ShadowDOM in dom that includes ALL styles\n    // processed here.\n    // 2. place stylesheets outside the element template. This will allow \n    // imports to naturally load the sheets. Then at load time, we can remove\n    // the stylesheet from dom.\n    installSheets: function() {\n      this.cacheSheets();\n      this.cacheStyles();\n      this.installLocalSheets();\n      this.installGlobalStyles();\n    },\n    /**\n     * Remove all sheets from element and store for later use.\n     */\n    cacheSheets: function() {\n      this.sheets = this.findNodes(SHEET_SELECTOR);\n      this.sheets.forEach(function(s) {\n        if (s.parentNode) {\n          s.parentNode.removeChild(s);\n        }\n      });\n    },\n    cacheStyles: function() {\n      this.styles = this.findNodes(STYLE_SELECTOR + '[' + SCOPE_ATTR + ']');\n      this.styles.forEach(function(s) {\n        if (s.parentNode) {\n          s.parentNode.removeChild(s);\n        }\n      });\n    },\n    /**\n     * Takes external stylesheets loaded in an <element> element and moves\n     * their content into a <style> element inside the <element>'s template.\n     * The sheet is then removed from the <element>. This is done only so \n     * that if the element is loaded in the main document, the sheet does\n     * not become active.\n     * Note, ignores sheets with the attribute 'polymer-scope'.\n     * @param elementElement The <element> element to style.\n     */\n    installLocalSheets: function () {\n      var sheets = this.sheets.filter(function(s) {\n        return !s.hasAttribute(SCOPE_ATTR);\n      });\n      var content = this.templateContent();\n      if (content) {\n        var cssText = '';\n        sheets.forEach(function(sheet) {\n          cssText += cssTextFromSheet(sheet) + '\\n';\n        });\n        if (cssText) {\n          var style = createStyleElement(cssText, this.ownerDocument);\n          content.insertBefore(style, content.firstChild);\n        }\n      }\n    },\n    findNodes: function(selector, matcher) {\n      var nodes = this.querySelectorAll(selector).array();\n      var content = this.templateContent();\n      if (content) {\n        var templateNodes = content.querySelectorAll(selector).array();\n        nodes = nodes.concat(templateNodes);\n      }\n      return matcher ? nodes.filter(matcher) : nodes;\n    },\n    templateContent: function() {\n      var template = this.querySelector('template');\n      return template && templateContent(template);\n    },\n    /**\n     * Promotes external stylesheets and <style> elements with the attribute \n     * polymer-scope='global' into global scope.\n     * This is particularly useful for defining @keyframe rules which \n     * currently do not function in scoped or shadow style elements.\n     * (See wkb.ug/72462)\n     * @param elementElement The <element> element to style.\n    */\n    // TODO(sorvell): remove when wkb.ug/72462 is addressed.\n    installGlobalStyles: function() {\n      var style = this.styleForScope(STYLE_GLOBAL_SCOPE);\n      applyStyleToScope(style, document.head);\n    },\n    cssTextForScope: function(scopeDescriptor) {\n      var cssText = '';\n      // handle stylesheets\n      var selector = '[' + SCOPE_ATTR + '=' + scopeDescriptor + ']';\n      var matcher = function(s) {\n        return matchesSelector(s, selector);\n      };\n      var sheets = this.sheets.filter(matcher);\n      sheets.forEach(function(sheet) {\n        cssText += cssTextFromSheet(sheet) + '\\n\\n';\n      });\n      // handle cached style elements\n      var styles = this.styles.filter(matcher);\n      styles.forEach(function(style) {\n        cssText += style.textContent + '\\n\\n';\n      });\n      return cssText;\n    },\n    styleForScope: function(scopeDescriptor) {\n      var cssText = this.cssTextForScope(scopeDescriptor);\n      return this.cssTextToScopeStyle(cssText, scopeDescriptor);\n    },\n    cssTextToScopeStyle: function(cssText, scopeDescriptor) {\n      if (cssText) {\n        var style = createStyleElement(cssText);\n        style.setAttribute(STYLE_SCOPE_ATTRIBUTE, this.getAttribute('name') +\n            '-' + scopeDescriptor);\n        return style;\n      }\n    }\n  };\n\n  function importRuleForSheet(sheet) {\n    return '@import \\'' + sheet.href + '\\';';\n  }\n\n  function applyStyleToScope(style, scope) {\n    if (style) {\n      // TODO(sorvell): necessary for IE\n      // see https://connect.microsoft.com/IE/feedback/details/790212/\n      // cloning-a-style-element-and-adding-to-document-produces\n      // -unexpected-result#details\n      // var clone = style.cloneNode(true);\n      var clone = createStyleElement(style.textContent);\n      var attr = style.getAttribute(STYLE_SCOPE_ATTRIBUTE);\n      if (attr) {\n        clone.setAttribute(STYLE_SCOPE_ATTRIBUTE, attr);\n      }\n      scope.appendChild(clone);\n    }\n  }\n\n  function createStyleElement(cssText, scope) {\n    scope = scope || document;\n    scope = scope.createElement ? scope : scope.ownerDocument;\n    var style = scope.createElement('style');\n    style.textContent = cssText;\n    return style;\n  }\n\n  function cssTextFromSheet(sheet) {\n    return (sheet && sheet.__resource) || '';\n  }\n\n  function matchesSelector(node, inSelector) {\n    if (matches) {\n      return matches.call(node, inSelector);\n    }\n  }\n  var p = HTMLElement.prototype;\n  var matches = p.matches || p.matchesSelector || p.webkitMatchesSelector \n      || p.mozMatchesSelector;\n  \n  // exports\n\n  scope.api.declaration.styles = styles;\n  scope.applyStyleToScope = applyStyleToScope;\n  \n})(Polymer);\n","/*\n * Copyright 2013 The Polymer Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style\n * license that can be found in the LICENSE file.\n */\n\n(function(scope) {\n\n  // imports\n\n  var api = scope.api.instance.events;\n  var log = window.logFlags || {};\n\n  // polymer-element declarative api: events feature\n\n  var events = { \n    parseHostEvents: function() {\n      // our delegates map\n      var delegates = this.prototype.eventDelegates;\n      // extract data from attributes into delegates\n      this.addAttributeDelegates(delegates);\n    },\n    addAttributeDelegates: function(delegates) {\n      // for each attribute\n      for (var i=0, a; a=this.attributes[i]; i++) {\n        // does it have magic marker identifying it as an event delegate?\n        if (api.hasEventPrefix(a.name)) {\n          // if so, add the info to delegates\n          delegates[api.removeEventPrefix(a.name)] = a.value.replace('{{', '')\n              .replace('}}', '').trim();\n        }\n      }\n    },\n    event_translations: {\n      webkitanimationstart: 'webkitAnimationStart',\n      webkitanimationend: 'webkitAnimationEnd',\n      webkittransitionend: 'webkitTransitionEnd',\n      domfocusout: 'DOMFocusOut',\n      domfocusin: 'DOMFocusIn',\n      dommousescroll: 'DOMMouseScroll'\n    }\n  };\n\n  // exports\n\n  scope.api.declaration.events = events;\n\n})(Polymer);","/*\n * Copyright 2013 The Polymer Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style\n * license that can be found in the LICENSE file.\n */\n(function(scope) {\n\n  // element api\n\n  var properties = {\n    inferObservers: function(prototype) {\n      // called before prototype.observe is chained to inherited object\n      var observe = prototype.observe, property;\n      for (var n in prototype) {\n        if (n.slice(-7) === 'Changed') {\n          if (!observe) {\n            observe  = (prototype.observe = {});\n          }\n          property = n.slice(0, -7)\n          observe[property] = observe[property] || n;\n        }\n      }\n    },\n    explodeObservers: function(prototype) {\n      // called before prototype.observe is chained to inherited object\n      var o = prototype.observe;\n      if (o) {\n        var exploded = {};\n        for (var n in o) {\n          var names = n.split(' ');\n          for (var i=0, ni; ni=names[i]; i++) {\n            exploded[ni] = o[n];\n          }\n        }\n        prototype.observe = exploded;\n      }\n    },\n    optimizePropertyMaps: function(prototype) {\n      if (prototype.observe) {\n        // construct name list\n        var a = prototype._observeNames = [];\n        for (var n in prototype.observe) {\n          var names = n.split(' ');\n          for (var i=0, ni; ni=names[i]; i++) {\n            a.push(ni);\n          }\n          //a.push(n);\n        }\n      }\n      if (prototype.publish) {\n        // construct name list\n        var a = prototype._publishNames = [];\n        for (var n in prototype.publish) {\n          a.push(n);\n        }\n      }\n    },\n    publishProperties: function(prototype, base) {\n      // if we have any properties to publish\n      var publish = prototype.publish;\n      if (publish) {\n        // transcribe `publish` entries onto own prototype\n        this.requireProperties(publish, prototype, base);\n        // construct map of lower-cased property names\n        prototype._publishLC = this.lowerCaseMap(publish);\n      }\n    },\n    requireProperties: function(properties, prototype, base) {\n      // ensure a prototype value for each property\n      for (var n in properties) {\n        if (prototype[n] === undefined && base[n] === undefined) {\n          prototype[n] = properties[n];\n        }\n      }\n    },\n    lowerCaseMap: function(properties) {\n      var map = {};\n      for (var n in properties) {\n        map[n.toLowerCase()] = n;\n      }\n      return map;\n    }\n  };\n\n  // exports\n\n  scope.api.declaration.properties = properties;\n\n})(Polymer);\n","/*\n * Copyright 2013 The Polymer Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style\n * license that can be found in the LICENSE file.\n */\n(function(scope) {\n\n  // magic words\n\n  var ATTRIBUTES_ATTRIBUTE = 'attributes';\n  var ATTRIBUTES_REGEX = /\\s|,/;\n\n  // attributes api\n\n  var attributes = {\n    inheritAttributesObjects: function(prototype) {\n      // chain our lower-cased publish map to the inherited version\n      this.inheritObject(prototype, 'publishLC');\n      // chain our instance attributes map to the inherited version\n      this.inheritObject(prototype, '_instanceAttributes');\n    },\n    publishAttributes: function(prototype, base) {\n      // merge names from 'attributes' attribute\n      var attributes = this.getAttribute(ATTRIBUTES_ATTRIBUTE);\n      if (attributes) {\n        // get properties to publish\n        var publish = prototype.publish || (prototype.publish = {});\n        // names='a b c' or names='a,b,c'\n        var names = attributes.split(ATTRIBUTES_REGEX);\n        // record each name for publishing\n        for (var i=0, l=names.length, n; i<l; i++) {\n          // remove excess ws\n          n = names[i].trim();\n          // do not override explicit entries\n          if (n && publish[n] === undefined && base[n] === undefined) {\n            publish[n] = null;\n          }\n        }\n      }\n    },\n    // record clonable attributes from <element>\n    accumulateInstanceAttributes: function() {\n      // inherit instance attributes\n      var clonable = this.prototype._instanceAttributes;\n      // merge attributes from element\n      var a$ = this.attributes;\n      for (var i=0, l=a$.length, a; (i<l) && (a=a$[i]); i++) {  \n        if (this.isInstanceAttribute(a.name)) {\n          clonable[a.name] = a.value;\n        }\n      }\n    },\n    isInstanceAttribute: function(name) {\n      return !this.blackList[name] && name.slice(0,3) !== 'on-';\n    },\n    // do not clone these attributes onto instances\n    blackList: {name: 1, 'extends': 1, constructor: 1, noscript: 1}\n  };\n\n  // add ATTRIBUTES_ATTRIBUTE to the blacklist\n  attributes.blackList[ATTRIBUTES_ATTRIBUTE] = 1;\n\n  // exports\n\n  scope.api.declaration.attributes = attributes;\n\n})(Polymer);\n","/*\n * Copyright 2013 The Polymer Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style\n * license that can be found in the LICENSE file.\n */\n(function(scope) {\n\n  // imports\n  \n  var api = scope.api;\n  var isBase = scope.isBase;\n  var extend = scope.extend;\n\n  // prototype api\n\n  var prototype = {\n    register: function(name, extendee) {\n      // build prototype combining extendee, Polymer base, and named api\n      this.prototype = this.buildPrototype(name, extendee);\n      // back reference declaration element\n      // TODO(sjmiles): replace `element` with `elementElement` or `declaration`\n      this.prototype.element = this;\n      // more declarative features\n      this.desugar(name, extendee);\n      // register our custom element with the platform\n      this.registerPrototype(name, extendee);\n      // reference constructor in a global named by 'constructor' attribute\n      this.publishConstructor();\n    },\n    buildPrototype: function(name, extendee) {\n      // get our custom prototype (before chaining)\n      var prototype = scope.getRegisteredPrototype(name);\n      // get basal prototype\n      var base = this.generateBasePrototype(extendee);\n      // transcribe `attributes` declarations onto own prototype's `publish`\n      this.publishAttributes(prototype, base);\n      // `publish` properties to the prototype and to attribute watch\n      this.publishProperties(prototype, base);\n      // infer observers for `observe` list based on method names\n      this.inferObservers(prototype);\n      // desugar compound observer syntax, e.g. 'a b c' \n      this.explodeObservers(prototype);\n      // chain various meta-data objects to inherited versions\n      this.inheritMetaData(prototype, base);\n      // chain custom api to inherited\n      prototype = this.chainObject(prototype, base);\n      // build side-chained lists to optimize iterations\n      this.optimizePropertyMaps(prototype);\n      // x-platform fixup\n      ensurePrototypeTraversal(prototype);\n      return prototype;\n    },\n    inheritMetaData: function(prototype, base) {\n      // chain observe object to inherited\n      this.inheritObject('observe', prototype, base);\n      // chain publish object to inherited\n      this.inheritObject('publish', prototype, base);\n      // chain our lower-cased publish map to the inherited version\n      this.inheritObject('_publishLC', prototype, base);\n      // chain our instance attributes map to the inherited version\n      this.inheritObject('_instanceAttributes', prototype, base);\n      // chain our event delegates map to the inherited version\n      this.inheritObject('eventDelegates', prototype, base);\n    },\n    // implement various declarative features\n    desugar: function(name, extendee) {\n      // install external stylesheets as if they are inline\n      this.installSheets();\n      // adjust any paths in dom from imports\n      this.resolveElementPaths(this);\n      // compile list of attributes to copy to instances\n      this.accumulateInstanceAttributes();\n      // parse on-* delegates declared on `this` element\n      this.parseHostEvents();\n      //\n      this.adjustShadowElement();\n      //\n      // TODO(sorvell): install a helper method this.resolvePath to aid in \n      // setting resource paths. e.g.\n      // this.$.image.src = this.resolvePath('images/foo.png')\n      // Potentially remove when spec bug is addressed.\n      // https://www.w3.org/Bugs/Public/show_bug.cgi?id=21407\n      this.addResolvePathApi();\n      // under ShadowDOMPolyfill, transforms to approximate missing CSS features\n      if (window.ShadowDOMPolyfill) {\n        Platform.ShadowCSS.shimStyling(this.templateContent(), name, extendee);\n      }\n      // allow custom element access to the declarative context\n      if (this.prototype.registerCallback) {\n        this.prototype.registerCallback(this);\n      }\n    },\n    // TODO(sorvell): remove when spec addressed:\n    // https://www.w3.org/Bugs/Public/show_bug.cgi?id=22460\n    // make <shadow></shadow> be <shadow><content></content></shadow>\n    adjustShadowElement: function() {\n      // TODO(sorvell): avoid under SD polyfill until this bug is addressed:\n      // https://github.com/Polymer/ShadowDOM/issues/297\n      if (!window.ShadowDOMPolyfill) {\n        var content = this.templateContent();\n        if (content) {\n          var s$ = content.querySelectorAll('shadow');\n          for (var i=0, l=s$.length, s; (i<l) && (s=s$[i]); i++) {\n            if (!s.children.length) {\n              s.appendChild(document.createElement('content'));\n            }\n          }\n        }\n      }\n    },\n    // if a named constructor is requested in element, map a reference\n    // to the constructor to the given symbol\n    publishConstructor: function() {\n      var symbol = this.getAttribute('constructor');\n      if (symbol) {\n        window[symbol] = this.ctor;\n      }\n    },\n    // build prototype combining extendee, Polymer base, and named api\n    generateBasePrototype: function(extnds) {\n      var prototype = this.findBasePrototype(extnds);\n      if (!prototype) {\n        // create a prototype based on tag-name extension\n        var prototype = HTMLElement.getPrototypeForTag(extnds);\n        // insert base api in inheritance chain (if needed)\n        prototype = this.ensureBaseApi(prototype);\n        // memoize this base\n        memoizedBases[extnds] = prototype;\n      }\n      return prototype;\n    },\n    findBasePrototype: function(name) {\n      return memoizedBases[name];\n    },\n    // install Polymer instance api into prototype chain, as needed \n    ensureBaseApi: function(prototype) {\n      if (prototype.PolymerBase) {\n        return prototype;\n      }\n      var extended = Object.create(prototype);\n      // we need a unique copy of base api for each base prototype\n      // therefore we 'extend' here instead of simply chaining\n      // we could memoize instead, especially for the common cases,\n      // in particular, for base === HTMLElement.prototype\n      for (var n in api.instance) {\n        extend(extended, api.instance[n]);\n      }\n      // TODO(sjmiles): sharing methods across prototype chains is\n      // not supported by our 'super' implementation which optimizes\n      // by memoizing prototype relationships.\n      // Probably we should have a version of 'extend' that is \n      // share-aware: it could study the text of each function,\n      // look for usage of 'super', and wrap those functions in\n      // closures.\n      // As of now, there is only one problematic method, so \n      // we just patch it manually.\n      // To avoid re-entrancy problems, the special super method\n      // installed is called `mixinSuper` and the mixin method\n      // must use this method instead of the default `super`.\n      this.mixinMethod(extended, prototype, api.instance.mdv, 'bind');\n      // return buffed-up prototype\n      return extended;\n    },\n    mixinMethod: function(extended, prototype, api, name) {\n      var $super = function(args) {\n        return prototype[name].apply(this, args);\n      };\n      extended[name] = function() {\n        this.mixinSuper = $super;\n        return api[name].apply(this, arguments);\n      }\n    },\n    // ensure prototype[name] inherits from a prototype.prototype[name]\n    inheritObject: function(name, prototype, base) {\n      // require an object\n      var source = prototype[name] || {};\n      // chain inherited properties onto a new object\n      prototype[name] = this.chainObject(source, base[name]);\n    },\n    // register 'prototype' to custom element 'name', store constructor \n    registerPrototype: function(name, extendee) { \n      var info = {\n        prototype: this.prototype\n      }\n      // native element must be specified in extends\n      var typeExtension = this.findTypeExtension(extendee);\n      if (typeExtension) {\n        info.extends = typeExtension;\n      }\n      // register the custom type\n      this.ctor = document.registerElement(name, info);\n      // constructor shenanigans\n      this.prototype.constructor = this.ctor;\n      // register the prototype with HTMLElement for name lookup\n      HTMLElement.register(name, this.prototype);\n    }, \n    findTypeExtension: function(name) {\n      if (name && name.indexOf('-') < 0) {\n        return name;\n      } else {\n        var p = this.findBasePrototype(name);\n        if (p.element) {\n          return this.findTypeExtension(p.element.extends);\n        }\n      }\n    }\n  };\n\n  // implementation of 'chainObject' depends on support for __proto__\n  if (Object.__proto__) {\n    prototype.chainObject = function(object, inherited) {\n      if (object && inherited && object !== inherited) {\n        object.__proto__ = inherited;\n      }\n      return object;\n    }\n  } else {\n    prototype.chainObject = function(object, inherited) {\n      if (object && inherited && object !== inherited) {\n        var chained = Object.create(inherited);\n        object = extend(chained, object);\n      }\n      return object;\n    }\n  }\n\n  // memoize base prototypes\n  memoizedBases = {};\n\n  // On platforms that do not support __proto__ (version of IE), the prototype\n  // chain of a custom element is simulated via installation of __proto__.\n  // Although custom elements manages this, we install it here so it's\n  // available during desugaring.\n  function ensurePrototypeTraversal(prototype) {\n    if (!Object.__proto__) {\n      var ancestor = Object.getPrototypeOf(prototype);\n      prototype.__proto__ = ancestor;\n      if (isBase(ancestor)) {\n        ancestor.__proto__ = Object.getPrototypeOf(ancestor);\n      }\n    }\n  }\n\n  // exports\n\n  api.declaration.prototype = prototype;\n\n})(Polymer);\n","/*\n * Copyright 2013 The Polymer Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style\n * license that can be found in the LICENSE file.\n */\n(function(scope) {\n\n  var queue = {\n    // tell the queue to wait for an element to be ready\n    wait: function(element) {\n      if (this.indexOf(element) === -1 && \n          (flushQueue.indexOf(element) === -1)) {\n        this.add(element);\n      }\n      return (this.indexOf(element) !== 0);\n    },\n    add: function(element) {\n      //console.log('queueing', element.name);\n      queueForElement(element).push(element);\n    },\n    indexOf: function(element) {\n      var i = queueForElement(element).indexOf(element);\n      if (i >= 0 && document.contains(element)) {\n        i += (HTMLImports.useNative || HTMLImports.ready) ? importQueue.length :\n            1e9;\n      }\n      return i;  \n    },\n    // tell the queue an element is ready to be registered\n    register: function(element) {\n      var readied = this.remove(element);\n      if (readied) {\n        flushQueue.push(readied);\n        this.check();\n      }\n    },\n    remove: function(element) {\n      var i = this.indexOf(element);\n      if (i !== 0) {\n        //console.warn('queue order wrong', i);\n        return;\n      }\n      return queueForElement(element).shift();  \n    },\n    check: function() {\n      // next\n      var element = this.nextElement();\n      if (element) {\n        element.registerWhenReady();\n      }\n      if (this.canFlush()) {\n        this.flush();\n        return true;\n      }\n    },\n    nextElement: function() {\n      return nextQueued();\n    },\n    canFlush: function() {\n      return !this.waitToFlush && this.isEmpty();\n    },\n    isEmpty: function() {\n      return !importQueue.length && !mainQueue.length;\n    },\n    flush: function() {\n      // TODO(sorvell): As an optimization, turn off CE polyfill upgrading\n      // while registering. This way we avoid having to upgrade each document\n      // piecemeal per registration and can instead register all elements\n      // and upgrade once in a batch. Without this optimization, upgrade time\n      // degrades significantly when SD polyfill is used. This is mainly because\n      // querying the document tree for elements is slow under the SD polyfill.\n      CustomElements.ready = false;\n      var element;\n      while (flushQueue.length) {\n        element = flushQueue.shift();\n        element._register();\n      }\n      CustomElements.upgradeDocumentTree(document);\n      CustomElements.ready = true;\n      this.flushReadyCallbacks();\n    },\n    flushReadyCallbacks: function() {\n      if (readyCallbacks) {\n        var fn;\n        while (readyCallbacks.length) {\n          fn = readyCallbacks.shift();\n          fn();\n        }\n      }\n    },\n    addReadyCallback: function(callback) {\n      readyCallbacks.push(callback);\n    },\n    waitToFlush: true\n  };\n\n  var importQueue = [];\n  var mainQueue = [];\n  var flushQueue = [];\n  var readyCallbacks = [];\n\n  function queueForElement(element) {\n    return document.contains(element) ? mainQueue : importQueue;\n  }\n\n  function nextQueued() {\n    return importQueue.length ? importQueue[0] : mainQueue[0];\n  }\n\n  var polymerReadied = false; \n  \n  function whenPolymerReady(callback) {\n    queue.waitToFlush = true;\n    HTMLImports.whenImportsReady(function() {\n      queue.addReadyCallback(callback);\n      queue.waitToFlush = false;\n      queue.check();\n    });\n  }\n\n  // exports\n  scope.queue = queue;\n  scope.whenPolymerReady = whenPolymerReady;\n})(Polymer);\n","/*\n * Copyright 2013 The Polymer Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style\n * license that can be found in the LICENSE file.\n */\n(function(scope) {\n\n  // imports\n\n  var extend = scope.extend;\n  var apis = scope.api.declaration;\n  var queue = scope.queue;\n  var whenPolymerReady = scope.whenPolymerReady;\n\n  // imperative implementation: Polymer()\n\n  // specify an 'own' prototype for tag `name`\n  function element(name, prototype) {\n    //console.log('registering prototype [' + name + ']');\n    // cache the prototype\n    prototypesByName[name] = prototype || {};\n    // notify the registrar waiting for 'name', if any\n    notifyPrototype(name);\n  }\n\n  // declarative implementation: <polymer-element>\n\n  var prototype = extend(Object.create(HTMLElement.prototype), {\n    createdCallback: function() {\n      if (this.getAttribute('name')) {\n        this.init();\n      }\n    },\n    init: function() {\n      // fetch the element name\n      this.name = this.getAttribute('name');\n      //console.log('createdCallback', this.name);\n      // fetch our extendee name\n      this.extends = this.getAttribute('extends');\n      this.loadResources();\n      this.registerWhenReady();\n    },\n    registerWhenReady: function() {\n      if (this.registered) {\n        return;\n      }\n      // if we have no prototype, wait\n      if (this.waitingForPrototype(this.name)) {\n        return;\n      }\n      if (this.waitingForQueue()) {\n        return;\n      }\n      if (this.waitingForResources()) {\n        return;\n      }\n      this.readyToRegister();\n    },\n    readyToRegister: function() {\n      queue.register(this);\n    },\n    _register: function() {\n      //console.log('registering', this.name);\n      //console.group('registering', this.name);\n      this.register(this.name, this.extends);\n      this.registered = true;\n      //console.groupEnd();\n    },\n    waitingForPrototype: function(name) {\n      if (!getRegisteredPrototype(name)) {\n        // then wait for a prototype\n        waitPrototype[name] = this;\n        // if explicitly marked as 'noscript'\n        if (this.hasAttribute('noscript') && !this.noscript) {\n          this.noscript = true;\n          // TODO(sorvell): CustomElements polyfill awareness:\n          // noscript elements should upgrade in logical order\n          // script injection ensures this under native custom elements;\n          // under imports + ce polyfills, scripts run before upgrades.\n          // dependencies should be ready at upgrade time so register\n          // prototype at this time.\n          if (window.CustomElements && !CustomElements.useNative) {\n            element(name);\n          } else {\n            var script = document.createElement('script');\n            script.textContent = 'Polymer(\\'' + name + '\\');';\n            this.appendChild(script);\n          }\n        }\n        return true;\n      }\n    },\n    waitingForResources: function() {\n      return this._needsResources;\n    },\n    // NOTE: Elements must be queued in proper order for inheritance/composition\n    // dependency resolution. Previously this was enforced for inheritance \n    // and by rule for composition. It's now entirely by rule.\n    waitingForQueue: function() {\n      return queue.wait(this);\n    },\n    loadResources: function() {\n      this._needsResources = true;\n      this.loadStyles(function() {\n        this._needsResources = false;\n        this.registerWhenReady();\n      }.bind(this));\n    }\n  });\n\n  // semi-pluggable APIs \n  // TODO(sjmiles): should be fully pluggable (aka decoupled, currently\n  // the various plugins are allowed to depend on each other directly)\n  Object.keys(apis).forEach(function(n) {\n    extend(prototype, apis[n]);\n  });\n\n  // utility and bookkeeping\n\n  // maps tag names to prototypes\n  var prototypesByName = {};\n\n  function getRegisteredPrototype(name) {\n    return prototypesByName[name];\n  }\n\n  // elements waiting for prototype, by name\n  var waitPrototype = {};\n\n  function notifyPrototype(name) {\n    if (waitPrototype[name]) {\n      waitPrototype[name].registerWhenReady();\n      delete waitPrototype[name];\n    }\n  }\n\n  // track document.register'ed tag names\n  var registered = {};\n\n  function isRegistered(name) {\n    return registered[name];\n  }\n\n  // exports\n  scope.getRegisteredPrototype = getRegisteredPrototype;\n  \n  // namespace shenanigans so we can expose our scope on the registration \n  // function\n\n  // TODO(sjmiles): find a way to do this that is less terrible\n  // copy window.Polymer properties onto `element()`\n  extend(element, scope);\n  // make window.Polymer reference `element()`\n  window.Polymer = element;\n\n  // Under the HTMLImports polyfill, scripts in the main document\n  // do not block on imports; we want to allow calls to Polymer in the main\n  // document. We do so via coordination with Platform:\n  var declarations = Platform.deliverDeclarations();\n  if (declarations) {\n    for (var i=0, l=declarations.length, d; (i<l) && (d=declarations[i]); i++) {\n      element.apply(null, d);\n    }\n  }\n\n  whenPolymerReady(function() {\n    document.dispatchEvent(\n      new CustomEvent('polymer-ready', {bubbles: true})\n    );\n  });\n\n  // register polymer-element with document\n  document.registerElement('polymer-element', {prototype: prototype});\n})(Polymer);\n"]}



<!--
 Copyright 2013 The Polymer Authors. All rights reserved.
 Use of this source code is governed by a BSD-style
 license that can be found in the LICENSE file.
-->
<script>// Copyright (c) 2012 The Polymer Authors. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//    * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//    * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//    * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// @version: 0.1.1-25e4df2
Polymer={},"function"==typeof window.Polymer&&(Polymer={}),function(a){function b(a,b){return a&&b&&Object.getOwnPropertyNames(b).forEach(function(c){var d=Object.getOwnPropertyDescriptor(b,c);d&&(Object.defineProperty(a,c,d),"function"==typeof d.value&&(d.value.nom=c))}),a}a.extend=b}(Polymer),function(a){function b(a,b,d){return a?a.stop():a=new c(this),a.go(b,d),a}var c=function(a){this.context=a};c.prototype={go:function(a,b){this.callback=a,this.handle=setTimeout(this.complete.bind(this),b)},stop:function(){this.handle&&(clearTimeout(this.handle),this.handle=null)},complete:function(){this.handle&&(this.stop(),this.callback.call(this.context))}},a.job=b}(Polymer),function(){var a={};HTMLElement.register=function(b,c){a[b]=c},HTMLElement.getPrototypeForTag=function(b){var c=b?a[b]:HTMLElement.prototype;return c||Object.getPrototypeOf(document.createElement(b))};var b=Event.prototype.stopPropagation;Event.prototype.stopPropagation=function(){this.cancelBubble=!0,b.apply(this,arguments)},HTMLImports.importer.preloadSelectors+=", polymer-element link[rel=stylesheet]"}(Polymer),function(a){function b(a){var c=b.caller,g=c.nom,h=c._super;if(h||(g||(g=c.nom=e.call(this,c)),g||console.warn("called super() on a method not installed declaratively (has no .nom property)"),h=d(c,g,f(this))),h){var i=h[g];return i._super||d(i,g,h),i.apply(this,a||[])}}function c(a,b,c){for(;a;){if(a[b]!==c&&a[b])return a;a=f(a)}}function d(a,b,d){return a._super=c(d,b,a),a._super&&(a._super[b].nom=b),a._super}function e(a){for(var b=this.__proto__;b&&b!==HTMLElement.prototype;){for(var c,d=Object.getOwnPropertyNames(b),e=0,f=d.length;f>e&&(c=d[e]);e++){var g=Object.getOwnPropertyDescriptor(b,c);if("function"==typeof g.value&&g.value===a)return c}b=b.__proto__}}function f(a){return a.__proto__}a.super=b}(Polymer),function(a){function b(a,b){var d=typeof b;return b instanceof Date&&(d="date"),c[d](a,b)}var c={string:function(a){return a},date:function(a){return new Date(Date.parse(a)||Date.now())},"boolean":function(a){return""===a?!0:"false"===a?!1:!!a},number:function(a){var b=parseFloat(a);return 0===b&&(b=parseInt(a)),isNaN(b)?a:b},object:function(a,b){if(null===b)return a;try{return JSON.parse(a.replace(/'/g,'"'))}catch(c){return a}},"function":function(a,b){return b}};a.deserializeValue=b}(Polymer),function(a){var b={};b.declaration={},b.instance={},a.api=b}(Polymer),function(a){var b={async:function(a,b,c){Platform.flush(),b=b&&b.length?b:[b];var d=function(){(this[a]||a).apply(this,b)}.bind(this);return c?setTimeout(d,c):requestAnimationFrame(d)},fire:function(a,b,c,d){var e=c||this;return e.dispatchEvent(new CustomEvent(a,{bubbles:void 0!==d?d:!0,detail:b})),b},asyncFire:function(){this.async("fire",arguments)},classFollows:function(a,b,c){b&&b.classList.remove(c),a&&a.classList.add(c)}},c=function(){},d={};b.asyncMethod=b.async,a.api.instance.utils=b,a.nop=c,a.nob=d}(Polymer),function(a){function b(a){for(;a.parentNode;)a=a.parentNode;return a.host}var c=window.logFlags||{},d="on-",e={EVENT_PREFIX:d,hasEventPrefix:function(a){return a&&"o"===a[0]&&"n"===a[1]&&"-"===a[2]},removeEventPrefix:function(a){return a.slice(f)},addHostListeners:function(){var a=this.eventDelegates;c.events&&Object.keys(a).length>0&&console.log("[%s] addHostListeners:",this.localName,a),this.addNodeListeners(this,a,this.hostEventListener)},addNodeListeners:function(a,b,c){var d;for(var e in b)d||(d=c.bind(this)),this.addNodeListener(a,e,d)},addNodeListener:function(a,b,c){a.addEventListener(b,c)},hostEventListener:function(a){if(!a.cancelBubble){c.events&&console.group("[%s]: hostEventListener(%s)",this.localName,a.type);var b=this.findEventDelegate(a);b&&(c.events&&console.log("[%s] found host handler name [%s]",this.localName,b),this.dispatchMethod(this,b,[a,a.detail,this])),c.events&&console.groupEnd()}},findEventDelegate:function(a){return this.eventDelegates[a.type]},dispatchMethod:function(a,b,d){if(a){c.events&&console.group("[%s] dispatch [%s]",a.localName,b);var e="function"==typeof b?b:a[b];e&&e[d?"apply":"call"](a,d),c.events&&console.groupEnd(),Platform.flush()}},prepareBinding:function(a,d){return e.hasEventPrefix(d)?function(f,g){c.events&&console.log('event: [%s].%s => [%s].%s()"',g.localName,f.localName,a);var h=function(c){var d=b(g);if(d&&d.dispatchMethod){var e=d,h=a;"@"==a[0]&&(e=f,h=Path.get(a.slice(1)).getValueFrom(f)),d.dispatchMethod(e,h,[c,c.detail,g])}},i=e.removeEventPrefix(d);return{open:function(){g.addEventListener(i,h,!1)},close:function(){c.events&&console.log('event.remove: [%s].%s => [%s].%s()"',g.localName,d,f.localName,a),g.removeEventListener(i,h,!1)},discardChanges:function(){}}}:void 0}},f=d.length;a.api.instance.events=e}(Polymer),function(a){var b={copyInstanceAttributes:function(){var a=this._instanceAttributes;for(var b in a)this.hasAttribute(b)||this.setAttribute(b,a[b])},takeAttributes:function(){if(this._publishLC)for(var a,b=0,c=this.attributes,d=c.length;(a=c[b])&&d>b;b++)this.attributeToProperty(a.name,a.value)},attributeToProperty:function(b,c){var b=this.propertyForAttribute(b);if(b){if(c&&c.search(a.bindPattern)>=0)return;var d=this[b],c=this.deserializeValue(c,d);c!==d&&(this[b]=c)}},propertyForAttribute:function(a){var b=this._publishLC&&this._publishLC[a];return b},deserializeValue:function(b,c){return a.deserializeValue(b,c)},serializeValue:function(a,b){return"boolean"===b?a?"":void 0:"object"!==b&&"function"!==b&&void 0!==a?a:void 0},reflectPropertyToAttribute:function(a){var b=typeof this[a],c=this.serializeValue(this[a],b);void 0!==c?this.setAttribute(a,c):"boolean"===b&&this.removeAttribute(a)}};a.api.instance.attributes=b}(Polymer),function(a){function b(a,b,d){c.bind&&console.log(e,inB.localName||"object",inPath,a.localName,b);var f=d.discardChanges();return(null===f||void 0===f)&&d.setValue(a[b]),Observer.defineComputedProperty(a,b,d)}var c=window.logFlags||{},d={observeProperties:function(){var a=this._observeNames,b=this._publishNames;if(a&&a.length||b&&b.length){for(var c,d=this._propertyObserver=new CompoundObserver,e=0,f=a.length;f>e&&(c=a[e]);e++){d.addPath(this,c);var g=Object.getOwnPropertyDescriptor(this.__proto__,c);g&&g.value&&this.observeArrayValue(c,g.value,null)}for(var c,e=0,f=b.length;f>e&&(c=b[e]);e++)this.observe&&void 0!==this.observe[c]||d.addPath(this,c);d.open(this.notifyPropertyChanges,this)}},notifyPropertyChanges:function(a,b,c){var d,e,f={};for(var g in b)d=c[2*g+1],void 0!==this.publish[d]&&this.reflectPropertyToAttribute(d),e=this.observe[d],e&&(this.observeArrayValue(d,a[g],b[g]),f[e]||(f[e]=!0,this.invokeMethod(e,[b[g],a[g],arguments])))},observeArrayValue:function(a,b,d){var e=this.observe[a];if(e&&(Array.isArray(d)&&(c.observe&&console.log("[%s] observeArrayValue: unregister observer [%s]",this.localName,a),this.unregisterObserver(a+"__array")),Array.isArray(b))){c.observe&&console.log("[%s] observeArrayValue: register observer [%s]",this.localName,a,b);var f=new ArrayObserver(b);f.open(function(a,b){this.invokeMethod(e,[b])},this),this.registerObserver(a+"__array",f)}},bindProperty:function(a,c){return b(this,a,c)},unbindAllProperties:function(){this._propertyObserver&&this._propertyObserver.close(),this.unregisterObservers()},unbindProperty:function(a){return this.unregisterObserver(a)},invokeMethod:function(a,b){var c=this[a]||a;"function"==typeof c&&c.apply(this,b)},registerObserver:function(a,b){var c=this._observers||(this._observers={});c[a]=b},unregisterObserver:function(a){var b=this._observers;return b&&b[a]?(b[a].close(),b[a]=null,!0):void 0},unregisterObservers:function(){if(this._observers){for(var a,b,c=Object.keys(this._observers),d=0,e=c.length;e>d&&(a=c[d]);d++)b=this._observers[a],b.close();this._observers={}}}},e="[%s]: bindProperties: [%s] to [%s].[%s]";a.api.instance.properties=d}(Polymer),function(a){function b(a){d(a,c)}function c(a){a.unbindAll()}function d(a,b){if(a){b(a);for(var c=a.firstChild;c;c=c.nextSibling)d(c,b)}}var e=window.logFlags||0,f=a.api.instance.events,g=PolymerExpressions.prototype.prepareBinding;PolymerExpressions.prototype.prepareBinding=function(a,b,c){return f.prepareBinding(a,b,c)||g.call(this,a,b,c)};var h=new PolymerExpressions,i={syntax:h,instanceTemplate:function(a){return a.bindingDelegate=this.syntax,a.createInstance(this)},bind:function(a,b){this._elementPrepared||this.prepareElement();var c=this.propertyForAttribute(a);if(c){this.unbind(a);var d=this.bindProperty(c,b);return d.path=b.path_,this.reflectPropertyToAttribute(c),this.bindings[a]=d}return this.super(arguments)},asyncUnbindAll:function(){this._unbound||(e.unbind&&console.log("[%s] asyncUnbindAll",this.localName),this._unbindAllJob=this.job(this._unbindAllJob,this.unbindAll,0))},unbindAll:function(){if(!this._unbound){this.unbindAllProperties(),this.super();for(var a=this.shadowRoot;a;)b(a),a=a.olderShadowRoot;this._unbound=!0}},cancelUnbindAll:function(a){return this._unbound?(e.unbind&&console.warn("[%s] already unbound, cannot cancel unbindAll",this.localName),void 0):(e.unbind&&console.log("[%s] cancelUnbindAll",this.localName),this._unbindAllJob&&(this._unbindAllJob=this._unbindAllJob.stop()),a||d(this.shadowRoot,function(a){a.cancelUnbindAll&&a.cancelUnbindAll()}),void 0)}},j=/\{\{([^{}]*)}}/;a.bindPattern=j,a.api.instance.mdv=i}(Polymer),function(a){function b(a){return a.hasOwnProperty("PolymerBase")}function c(){}var d=0,e={PolymerBase:!0,job:Polymer.job,"super":Polymer.super,created:function(){},ready:function(){},createdCallback:function(){this.created(),(this.ownerDocument.defaultView||this.alwaysPrepare||d>0)&&this.prepareElement()},prepareElement:function(){this._elementPrepared=!0,this.observeProperties(),this.copyInstanceAttributes(),this.takeAttributes(),this.addHostListeners(),d++,this.parseDeclarations(this.__proto__),d--,this.ready()},attachedCallback:function(){this._elementPrepared||this.prepareElement(),this.cancelUnbindAll(!0),this.attached&&this.attached(),this.enteredView&&this.enteredView()},detachedCallback:function(){this.preventDispose||this.asyncUnbindAll(),this.detached&&this.detached(),this.leftView&&this.leftView()},enteredViewCallback:function(){this.attachedCallback()},leftViewCallback:function(){this.detachedCallback()},enteredDocumentCallback:function(){this.attachedCallback()},leftDocumentCallback:function(){this.detachedCallback()},parseDeclarations:function(a){a&&a.element&&(this.parseDeclarations(a.__proto__),a.parseDeclaration.call(this,a.element))},parseDeclaration:function(a){var b=this.fetchTemplate(a);b&&(this.element.hasAttribute("lightdom")?this.lightFromTemplate(b):this.shadowFromTemplate(b))},fetchTemplate:function(a){return a.querySelector("template")},shadowFromTemplate:function(a){if(a){var b=(this.shadowRoot,this.createShadowRoot());b.applyAuthorStyles=this.applyAuthorStyles,b.resetStyleInheritance=this.resetStyleInheritance;var c=this.instanceTemplate(a);return b.appendChild(c),this.shadowRootReady(b,a),b}},lightFromTemplate:function(a){if(a){var b=this.instanceTemplate(a);return this.appendChild(b),this.shadowRootReady(this,a),b}},shadowRootReady:function(a){this.marshalNodeReferences(a),PointerGestures.register(a)},marshalNodeReferences:function(a){var b=this.$=this.$||{};if(a)for(var c,d=a.querySelectorAll("[id]"),e=0,f=d.length;f>e&&(c=d[e]);e++)b[c.id]=c},attributeChangedCallback:function(a){"class"!==a&&"style"!==a&&this.attributeToProperty(a,this.getAttribute(a)),this.attributeChanged&&this.attributeChanged.apply(this,arguments)},onMutation:function(a,b){var c=new MutationObserver(function(a){b.call(this,c,a),c.disconnect()}.bind(this));c.observe(a,{childList:!0,subtree:!0})}};c.prototype=e,e.constructor=c,a.Base=c,a.isBase=b,a.api.instance.base=e}(Polymer),function(a){function b(a){return a.__proto__}var c=(window.logFlags||{},"element"),d="controller",e={STYLE_SCOPE_ATTRIBUTE:c,installControllerStyles:function(){var a=this.findStyleController();if(a&&!this.scopeHasElementStyle(a,d)){for(var c=b(this),e="";c&&c.element;)e+=c.element.cssTextForScope(d),c=b(c);if(e){var f=this.element.cssTextToScopeStyle(e,d);Polymer.applyStyleToScope(f,a)}}},findStyleController:function(){if(window.ShadowDOMPolyfill)return wrap(document.head);for(var a=this;a.parentNode;)a=a.parentNode;return a===document?document.head:a},scopeHasElementStyle:function(a,b){var d=c+"="+this.localName+"-"+b;return a.querySelector("style["+d+"]")}};a.api.instance.styles=e}(Polymer),function(a){var b={addResolvePathApi:function(){var a=this.elementPath(),b=this.getAttribute("assetpath")||"",c=this.relPath;this.prototype.resolvePath=function(d){var e=d;if(b){var f=b.slice(0,-1);e=c(f,e)}return a+b+e}},elementPath:function(){return this.urlToPath(HTMLImports.getDocumentUrl(this.ownerDocument))},relPath:function(a,b){for(var c=a.split("/"),d=b.split("/"),e=!1;c.length&&d.length&&c[0]===d[0];)c.shift(),d.shift(),e=!0;if(e)for(var f=0;f<c.length;f++)d.unshift("..");return d.join("/")},urlToPath:function(a){if(a){var b=a.split("/");return b.pop(),b.push(""),b.join("/")}return""}};a.api.declaration.path=b}(Polymer),function(a){function b(a,b){if(a){var d=c(a.textContent),e=a.getAttribute(g);e&&d.setAttribute(g,e),b.appendChild(d)}}function c(a){var b=document.createElement("style");return b.textContent=a,b}function d(a){return a&&a.__resource||""}function e(a,b){return n?n.call(a,b):void 0}var f=(window.logFlags||{},a.api.instance.styles),g=f.STYLE_SCOPE_ATTRIBUTE,h="style",i="[rel=stylesheet]",j="global",k="polymer-scope",l={installSheets:function(){this.cacheSheets(),this.cacheStyles(),this.installLocalSheets(),this.installGlobalStyles()},cacheSheets:function(){this.sheets=this.findNodes(i),this.sheets.forEach(function(a){a.parentNode&&a.parentNode.removeChild(a)})},cacheStyles:function(){this.styles=this.findNodes(h+"["+k+"]"),this.styles.forEach(function(a){a.parentNode&&a.parentNode.removeChild(a)})},installLocalSheets:function(){var a=this.sheets.filter(function(a){return!a.hasAttribute(k)}),b=this.templateContent();if(b){var e="";a.forEach(function(a){e+=d(a)+"\n"}),e&&b.insertBefore(c(e),b.firstChild)}},findNodes:function(a,b){var c=this.querySelectorAll(a).array(),d=this.templateContent();if(d){var e=d.querySelectorAll(a).array();c=c.concat(e)}return b?c.filter(b):c},templateContent:function(){var a=this.querySelector("template");return a&&templateContent(a)},installGlobalStyles:function(){var a=this.styleForScope(j);b(a,document.head)},cssTextForScope:function(a){var b="",c="["+k+"="+a+"]",f=function(a){return e(a,c)},g=this.sheets.filter(f);g.forEach(function(a){b+=d(a)+"\n\n"});var h=this.styles.filter(f);return h.forEach(function(a){b+=a.textContent+"\n\n"}),b},styleForScope:function(a){var b=this.cssTextForScope(a);return this.cssTextToScopeStyle(b,a)},cssTextToScopeStyle:function(a,b){if(a){var d=c(a);return d.setAttribute(g,this.getAttribute("name")+"-"+b),d}}},m=HTMLElement.prototype,n=m.matches||m.matchesSelector||m.webkitMatchesSelector||m.mozMatchesSelector;a.api.declaration.styles=l,a.applyStyleToScope=b}(Polymer),function(a){var b=a.api.instance.events,c=(window.logFlags||{},{parseHostEvents:function(){var a=this.prototype.eventDelegates;this.addAttributeDelegates(a)},addAttributeDelegates:function(a){for(var c,d=0;c=this.attributes[d];d++)b.hasEventPrefix(c.name)&&(a[b.removeEventPrefix(c.name)]=c.value.replace("{{","").replace("}}","").trim())},event_translations:{webkitanimationstart:"webkitAnimationStart",webkitanimationend:"webkitAnimationEnd",webkittransitionend:"webkitTransitionEnd",domfocusout:"DOMFocusOut",domfocusin:"DOMFocusIn",dommousescroll:"DOMMouseScroll"}});a.api.declaration.events=c}(Polymer),function(a){var b={inferObservers:function(a){var b,c=a.observe;for(var d in a)"Changed"===d.slice(-7)&&(c||(c=a.observe={}),b=d.slice(0,-7),c[b]=c[b]||d)},explodeObservers:function(a){var b=a.observe;if(b){var c={};for(var d in b)for(var e,f=d.split(" "),g=0;e=f[g];g++)c[e]=b[d];a.observe=c}},optimizePropertyMaps:function(a){if(a.observe){var b=a._observeNames=[];for(var c in a.observe)for(var d,e=c.split(" "),f=0;d=e[f];f++)b.push(d)}if(a.publish){var b=a._publishNames=[];for(var c in a.publish)b.push(c)}},publishProperties:function(a,b){var c=a.publish;c&&(this.requireProperties(c,a,b),a._publishLC=this.lowerCaseMap(c))},requireProperties:function(a,b,c){for(var d in a)void 0===b[d]&&void 0===c[d]&&(b[d]=a[d])},lowerCaseMap:function(a){var b={};for(var c in a)b[c.toLowerCase()]=c;return b}};a.api.declaration.properties=b}(Polymer),function(a){var b="attributes",c={inheritAttributesObjects:function(a){this.inheritObject(a,"publishLC"),this.inheritObject(a,"_instanceAttributes")},publishAttributes:function(a,c){var d=this.getAttribute(b);if(d)for(var e,f=a.publish||(a.publish={}),g=d.split(d.indexOf(",")>=0?",":" "),h=0,i=g.length;i>h;h++)e=g[h].trim(),e&&void 0===f[e]&&void 0===c[e]&&(f[e]=null)},accumulateInstanceAttributes:function(){for(var a,b=this.prototype._instanceAttributes,c=this.attributes,d=0,e=c.length;e>d&&(a=c[d]);d++)this.isInstanceAttribute(a.name)&&(b[a.name]=a.value)},isInstanceAttribute:function(a){return!this.blackList[a]&&"on-"!==a.slice(0,3)},blackList:{name:1,"extends":1,constructor:1,noscript:1}};c.blackList[b]=1,a.api.declaration.attributes=c}(Polymer),function(a){function b(a){if(!Object.__proto__){var b=Object.getPrototypeOf(a);a.__proto__=b,d(b)&&(b.__proto__=Object.getPrototypeOf(b))}}var c=a.api,d=a.isBase,e=a.extend,f={register:function(a,b){this.prototype=this.buildPrototype(a,b),this.prototype.element=this,this.desugar(a,b),this.registerPrototype(a,b),this.publishConstructor()},buildPrototype:function(c,d){var e=a.getRegisteredPrototype(c),f=this.generateBasePrototype(d);return this.publishAttributes(e,f),this.publishProperties(e,f),this.inferObservers(e),this.explodeObservers(e),this.inheritMetaData(e,f),e=this.chainObject(e,f),this.optimizePropertyMaps(e),b(e),e},inheritMetaData:function(a,b){this.inheritObject("observe",a,b),this.inheritObject("publish",a,b),this.inheritObject("_publishLC",a,b),this.inheritObject("_instanceAttributes",a,b),this.inheritObject("eventDelegates",a,b)},desugar:function(a,b){this.accumulateInstanceAttributes(),this.parseHostEvents(),this.installSheets(),this.adjustShadowElement(),this.addResolvePathApi(),window.ShadowDOMPolyfill&&Platform.ShadowCSS.shimStyling(this.templateContent(),a,b),this.prototype.registerCallback&&this.prototype.registerCallback(this)},adjustShadowElement:function(){if(!window.ShadowDOMPolyfill){var a=this.templateContent();if(a)for(var b,c=a.querySelectorAll("shadow"),d=0,e=c.length;e>d&&(b=c[d]);d++)b.children.length||b.appendChild(document.createElement("content"))}},publishConstructor:function(){var a=this.getAttribute("constructor");a&&(window[a]=this.ctor)},generateBasePrototype:function(a){var b=this.findBasePrototype(a);if(!b){var b=HTMLElement.getPrototypeForTag(a);b=this.ensureBaseApi(b),memoizedBases[a]=b}return b},findBasePrototype:function(a){return memoizedBases[a]},ensureBaseApi:function(a){if(a.PolymerBase)return a;var b=Object.create(a);for(var d in c.instance)e(b,c.instance[d]);return this.mixinMethod(b,a,c.instance.mdv,"bind"),b},mixinMethod:function(a,b,c,d){var e=function(a){return b[d].apply(this,a)};a[d]=function(){this.super=e;var b=c[d].apply(this,arguments);return this.super=a.super,b}},inheritObject:function(a,b,c){var d=b[a]||{};b[a]=this.chainObject(d,c[a])},registerPrototype:function(a,b){var c={prototype:this.prototype},d=this.findTypeExtension(b);d&&(c.extends=d),this.ctor=document.registerElement(a,c),this.prototype.constructor=this.ctor,HTMLElement.register(a,this.prototype)},findTypeExtension:function(a){if(a&&a.indexOf("-")<0)return a;var b=this.findBasePrototype(a);return b.element?this.findTypeExtension(b.element.extends):void 0}};f.chainObject=Object.__proto__?function(a,b){return a&&b&&a!==b&&(a.__proto__=b),a}:function(a,b){if(a&&b&&a!==b){var c=Object.create(b);a=e(c,a)}return a},memoizedBases={},c.declaration.prototype=f}(Polymer),function(a){function b(a,b){k[a]=b||{},d(a)}function c(a){return k[a]}function d(a){l[a]&&(l[a].registerWhenReady(),delete l[a])}function e(a){n[a]=!0;var b=m[a];b&&(b.forEach(function(a){a.registerWhenReady()}),delete m[a])}function f(a){return n[a]}function g(a){window.HTMLImports&&!HTMLImports.readyTime?addEventListener("HTMLImportsLoaded",a):a()}var h=a.extend,i=a.api.declaration,j=h(Object.create(HTMLElement.prototype),{createdCallback:function(){this.name=this.getAttribute("name"),this.extends=this.getAttribute("extends"),this.registerWhenReady()},registerWhenReady:function(){if(!this.waitingForPrototype(this.name)){var a=this.extends;this.waitingForExtendee(a)||(document.contains(this)?g(function(){this._register(a)}.bind(this)):this._register(a))}},_register:function(a){this.register(this.name,a),e(this.name)},waitingForPrototype:function(a){if(!c(a)){if(l[a]=this,this.hasAttribute("noscript"))if(window.CustomElements&&!CustomElements.useNative)b(a);else{var d=document.createElement("script");d.textContent="Polymer('"+a+"');",this.appendChild(d)}return!0}},waitingForExtendee:function(a){return a&&a.indexOf("-")>=0&&!f(a)?((m[a]=m[a]||[]).push(this),!0):void 0}});Object.keys(i).forEach(function(a){h(j,i[a])});var k={},l={},m={},n={};a.getRegisteredPrototype=c,h(b,a),window.Polymer=b;var o=Platform.deliverDeclarations();if(o)for(var p,q=0,r=o.length;r>q&&(p=o[q]);q++)b.apply(null,p);document.registerElement("polymer-element",{prototype:j})}(Polymer);
//# sourceMappingURL=polymer.js.map</script>
<!-- <link rel="import" href="../polymer-dev/polymer.html"> -->
<!--
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
-->
<!--
/**
 * @module Polymer Elements
 */
/**
 * polymer-xhr can be used to perform XMLHttpRequests.
 
 * Example:
 *
 *     <polymer-xhr id="xhr"></polymer-xhr>
 *     ...
 *     this.$.xhr.request({url: url, params: params, callback: callback});
 *
 * @class polymer-xhr
 */
-->


<polymer-element name="polymer-xhr" assetpath="../polymer-ajax/">
  <template>
    <style>
      :host {
        display: none;
      }
    </style>
  </template>
  <script>
    Polymer('polymer-xhr', {
      makeReadyStateHandler: function(xhr, callback) {
        xhr.onreadystatechange = function() {
          if (xhr.readyState == 4) {
            callback && callback.call(null, xhr.response, xhr);
          }
        };
      },
      setRequestHeaders: function(xhr, headers) {
        if (headers) {
          for (var name in headers) {
            xhr.setRequestHeader(name, headers[name]);
          }
        }
      },
      toQueryString: function(params) {
        var r = [];
        for (var n in params) {
          var v = params[n];
          n = encodeURIComponent(n);
          r.push(v == null ? n : (n + '=' + encodeURIComponent(v)));
        }
        return r.join('&');
      },
      /**
       * Sends a HTTP request to the server and returns the XHR object.
       *
       * @method request
       * @param {Object} inOptions
       *    @param {String} inOptions.url The url to which the request is sent.
       *    @param {String} inOptions.method The HTTP method to use, default is GET.
       *    @param {boolean} inOptions.sync By default, all requests are sent asynchronously.
       *        To send synchronous requests, set to true.
       *    @param {Object} inOptions.params Data to be sent to the server.
       *    @param {Object} inOptions.body The content for the request body for POST method.
       *    @param {Object} inOptions.headers HTTP request headers.
       *    @param {String} inOptions.responseType The response type. Default is 'text'.
       *    @param {Object} inOptions.callback Called when request is completed.
       * @returns {Object} XHR object.
       */
      request: function(options) {
        var xhr = new XMLHttpRequest();
        var url = options.url;
        var method = options.method || 'GET';
        var async = !options.sync;
        var params = this.toQueryString(options.params);
        if (params && method == 'GET') {
          url += (url.indexOf('?') > 0 ? '&' : '?') + params;
        }
        xhr.open(method, url, async);
        if (options.responseType) {
          xhr.responseType = options.responseType;
        }
        this.makeReadyStateHandler(xhr, options.callback);
        this.setRequestHeaders(xhr, options.headers);
        xhr.send(method == 'POST' ? (options.body || params) : null);
        if (!async) {
          xhr.onreadystatechange(xhr);
        }
        return xhr;
      }
    });
  </script>
</polymer-element>

<!--
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
-->
<!--
/**
 * @module Polymer Elements
 */
/**
 * polymer-ajax can be used to perform XMLHttpRequests.
 *
 * Example:
 *
 *     <polymer-ajax auto url="http://gdata.youtube.com/feeds/api/videos/" 
 *         params='{"alt":"json", "q":"chrome"}'
 *         handleAs="json"
 *         on-polymer-response="{{handleResponse}}">
 *     </polymer-ajax>
 *
 * @class polymer-ajax
 */
/**
 * Fired when a response is received.
 * 
 * @event polymer-response
 */
/**
 * Fired when an error is received.
 * 
 * @event polymer-error
 */
/**
 * Fired whenever a response or an error is received.
 *
 * @event polymer-complete
 */
-->



<polymer-element name="polymer-ajax" attributes="url handleAs auto params response method headers contentType" assetpath="../polymer-ajax/">
  <script>
    Polymer('polymer-ajax', {
      /**
       * The URL target of the request.
       * 
       * @attribute url
       * @type string
       * @default ''
       */
      url: '',
      /**
       * Specifies what data to store in the 'response' property, and
       * to deliver as 'event.response' in 'response' events.
       * 
       * One of:
       * 
       *    `text`: uses XHR.responseText
       *    
       *    `xml`: uses XHR.responseXML
       *    
       *    `json`: uses XHR.responseText parsed as JSON
       *  
       * @attribute handleAs
       * @type string
       * @default 'text'
       */
      handleAs: '',
      /**
       * If true, automatically performs an Ajax request when either url or params has changed.
       *
       * @attribute auto
       * @type boolean
       * @default false
       */
      auto: false,
      /**
       * Parameters to send to the specified URL, as JSON.
       *  
       * @attribute params
       * @type string (JSON)
       * @default ''
       */
      params: '',
      /**
       * Returns the response object.
       *
       * @attribute response
       * @type Object
       * @default null
       */
      response: null,
      /**
       * The HTTP method to use such as 'GET', 'POST', 'PUT', 'DELETE'.
       * Default is 'GET'.
       *
       * @attribute method
       * @type string
       * @default ''
       */
      method: '',
      /**
       * HTTP request headers to send.
       *
       * Example:
       *
       *     <polymer-ajax auto url="http://somesite.com"
       *         headers='{"X-Requested-With": "XMLHttpRequest"}'
       *         handleAs="json"
       *         on-polymer-response="{{handleResponse}}">
       *     </polymer-ajax>
       *  
       * @attribute headers
       * @type Object
       * @default null
       */
      headers: null,
      /**
       * Optional raw body content to send when method === "POST"
       *
       * Example:
       *
       *     <polymer-ajax method="POST" auto url="http://somesite.com"
       *         body='{"foo":1, "bar":2}'>
       *     </polymer-ajax>
       *  
       * @attribute body
       * @type Object
       * @default null
       */
      body: null,
      /**
       * Content type to use when sending data.
       *
       * @attribute contentType
       * @type string
       * @default 'application/x-www-form-urlencoded'
       */
      contentType: 'application/x-www-form-urlencoded',
      ready: function() {
        this.xhr = document.createElement('polymer-xhr');
      },
      receive: function(response, xhr) {
        if (this.isSuccess(xhr)) {
          this.processResponse(xhr);
        } else {
          this.error(xhr);
        }
        this.complete(xhr);
      },
      isSuccess: function(xhr) {
        var status = xhr.status || 0;
        return !status || (status >= 200 && status < 300);
      },
      processResponse: function(xhr) {
        var response = this.evalResponse(xhr);
        this.response = response;
        this.fire('polymer-response', {response: response, xhr: xhr});
      },
      error: function(xhr) {
        var response = xhr.status + ': ' + xhr.responseText;
        this.fire('polymer-error', {response: response, xhr: xhr});
      },
      complete: function(xhr) {
        this.fire('polymer-complete', {response: xhr.status, xhr: xhr});
      },
      evalResponse: function(xhr) {
        return this[(this.handleAs || 'text') + 'Handler'](xhr);
      },
      xmlHandler: function(xhr) {
        return xhr.responseXML;
      },
      textHandler: function(xhr) {
        return xhr.responseText;
      },
      jsonHandler: function(xhr) {
        var r = xhr.responseText;
        try {
          return JSON.parse(r);
        } catch (x) {
          return r;
        }
      },
      urlChanged: function() {
        if (!this.handleAs) {
          var ext = String(this.url).split('.').pop();
          switch (ext) {
            case 'json':
              this.handleAs = 'json';
              break;
          }
        }
        this.autoGo();
      },
      paramsChanged: function() {
        this.autoGo();
      },
      autoChanged: function() {
        this.autoGo();
      },
      // TODO(sorvell): multiple side-effects could call autoGo 
      // during one micro-task, use a job to have only one action 
      // occur
      autoGo: function() {
        if (this.auto) {
          this.goJob = this.job(this.goJob, this.go, 0);
        }
      },
      /**
       * Performs an Ajax request to the url specified.
       *
       * @method go
       */
      go: function() {
        var args = this.xhrArgs || {};
        // TODO(sjmiles): alternatively, we could force POST if body is set
        if (this.method === 'POST') {
          args.body = this.body || args.body;
        }
        args.params = this.params || args.params;
        if (args.params && typeof(args.params) == 'string') {
          args.params = JSON.parse(args.params);
        }
        args.headers = this.headers || args.headers || {};
        if (args.headers && typeof(args.headers) == 'string') {
          args.headers = JSON.parse(args.headers);
        }
        if (this.contentType) {
          args.headers['content-type'] = this.contentType;
        }
        args.callback = this.receive.bind(this);
        args.url = this.url;
        args.method = this.method;
        return args.url && this.xhr.request(args);
      }
    });
  </script>
</polymer-element>

<!--
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
-->
<!--
/**
 * @module Polymer Elements
 */
/**
 * `<polymer-layout>` arranges nodes horizontally via absolution positioning.
 * Set the `vertical` attribute (boolean) to arrange vertically instead.
 * 
 * `<polymer-layout>` arranges it's <b>sibling elements</b>, not
 * it's children.
 *
 * One arranged node may be marked as elastic by giving it a `flex`
 * attribute (boolean).
 *
 * You may remove a node from layout by giving it a `nolayout`
 * attribute (boolean).
 * 
 * CSS Notes:
 *
 *  * `padding` is ignored on the parent node.
 *  * `margin` is ignored on arranged nodes.
 *  * `min-width` is ignored on arranged nodes, use `min-width` on the parent node
 *    instead.
 *
 * Example: 
 *
 * Arrange three `div` into columns. `flex` attribute on Column Two makes that
 * column elastic.
 *
 *      <polymer-layout></polymer-layout>
 *      <div>Column One</div>
 *      <div flex>Column Two</div>
 *      <div>Column Three</div>
 *
 *  Remember that `<polymer-layout>` arranges it's sibling elements, not it's children.
 *
 * If body has width 52 device pixels (in this case, ascii characters), call that 52px.
 * Column One has it's natural width of 12px (including border), Column Three has it's
 * natural width of 14px, body border uses 2px, and Column Two automatically uses the
 * remaining space: 24px.
 *
 *      |-                    52px                        -| 
 *      ----------------------------------------------------
 *      ||Column One||      Column Two      ||Column Three||
 *      ----------------------------------------------------
 *       |-  12px  -||-     (24px)         -||    14px   -|
 *
 * As the parent node resizes, the elastic column reacts via CSS to adjust it's size.
 * No javascript is used during parent resizing, for best performance. 
 *
 * Changes in content or sibling size is not handled automatically. 
 *
 *      ----------------------------------------------------------------
 *      ||Column One|             Column Two             |Column Three||
 *      ----------------------------------------------------------------
 *
 *      --------------------------------------
 *      ||Column One|Column Two|Column Three||
 *      --------------------------------------
 *
 * Arrange in rows by adding the `vertical` attribute.
 *
 * Example:
 *
 *      <polymer-layout vertical></polymer-layout>
 *      <div>Row One</div>
 *      <div flex>Row Two</div>
 *      <div>Row Three</div>
 *
 * This setup will cause Row Two to stretch to fill the container.
 *
 *      -----------             -----------
 *      |---------|             |---------|
 *      |         |             |         |
 *      |Row One  |             |Row One  |
 *      |         |             |         |
 *      |---------|             |---------|
 *      |         |             |         |
 *      |Row Two  |             |Row Two  |
 *      |         |             |         |
 *      |---------|             |         |
 *      |         |             |         |
 *      |Row Three|             |         |
 *      |         |             |---------|
 *      |---------|             |         |
 *      -----------             |Row Three|
 *                              |         |
 *                              |---------|
 *                              |---------|
 *
 * Layouts can be nested arbitrarily.
 *
 *      <polymer-layout></polymer-layout>
 *      <div>Menu</div>
 *      <div flex>
 *         <polymer-layout vertical></polymer-layout>
 *         <div>Title</div>
 *         <div>Toolbar</div>
 *         <div flex>Main</div>
 *         <div>Footer</div>
 *      </div>
 *
 * Renders something like this
 *
 *      --------------------------------
 *      ||Menu     ||Title            ||
 *      ||         ||-----------------||
 *      ||         ||Toolbar          ||
 *      ||         ||-----------------||
 *      ||         ||Main             ||
 *      ||         ||                 ||
 *      ||         ||-----------------||
 *      ||         ||Footer           ||
 *      --------------------------------
 *
 * @class polymer-layout
 *
 */
-->


<polymer-element name="polymer-layout" attributes="vertical" assetpath="../polymer-layout/">
  <template>
    <style>
      :host {
        display: none;
      }
    </style>
  </template>
  <script>
    Polymer('polymer-layout', {
      vertical: false,
      ready: function() {
        this.setAttribute('nolayout', '');
      },
      enteredView: function() {
        this.asyncMethod(function() {
          this.prepare();
          this.layout();
        });
      },
      prepare: function() {
        var parent = this.parentNode.host || this.parentNode;
        // explicit position harmful on <body>
        if (parent.localName !== 'body') {
        // may recalc
          var cs = window.getComputedStyle(parent);
          if (cs.position === 'static') {
            parent.style.position = 'relative';
          }
          //parent.style.overflow = 'hidden';
        }
        // changes will cause another recalc at next validation step
        var vertical;
        this.parentNode.childNodes.array().forEach(function(c, i) {
          if (c.nodeType === Node.ELEMENT_NODE && !c.hasAttribute('nolayout')) {
            stylize(c, {
              position: 'absolute',
              boxSizing: 'border-box',
              MozBoxSizing: 'border-box',
            });
            // test for auto-vertical
            if (vertical === undefined) {
              vertical = (c.offsetWidth == 0 && c.offsetHeight !== 0);
            }
          }
        });
        this.vertical = this.vertical || vertical;
      },
      /**
       * Arrange sibling nodes end-to-end in one dimension.
       *
       * Arrangement is horizontal unless the `vertical`
       * attribute is applied on this node.
       *
       * @method layout
       */
      layout: function() {
        var parent = this.parentNode.host || this.parentNode;
        var vertical = this.vertical;
        var ww = 0, hh = 0, pre = [], fit, post = [];
        var list = pre;
        // gather element information (at most one recalc)
        this.parentNode.childNodes.array().forEach(function(c, i) {
          if (c.nodeType===Node.ELEMENT_NODE && !c.hasAttribute('nolayout')) {
            var info = {
              element: c,
              w: c.offsetWidth,
              h: c.offsetHeight
            };
            if (!c.hasAttribute('fit') && !c.hasAttribute('flex')) {
              ww += c.offsetWidth;
              hh += c.offsetHeight;
              list.push(info);
            } else {
              fit = c;
              list = post;
              ww = hh = 0;
            }
          }
        });
        // update layout styles (invalidate, no recalc)
        var v = 0;
        var mxp = 0, myp = 0;
        pre.forEach(function(info) {
          if (vertical) {
            stylize(info.element, {
              top: v + 'px', right: mxp, height: info.h + 'px', left: mxp
            });
          } else {
            stylize(info.element, {
              top: myp, width: info.w + 'px', bottom: myp, left: v + 'px'
            });
          }
          v += vertical ? info.h : info.w;
        });
        if (fit) {
          if (vertical) {
            stylize(fit, {
              top: v + 'px', right: mxp, bottom: hh + 'px', left: mxp
            });
          } else {
            stylize(fit, {
              top: myp, right: ww + 'px', bottom: myp, left: v + 'px'
            });
          }
          v = vertical ? hh : ww;
          post.forEach(function(info) {
            v -= vertical ? info.h : info.w;
            if (vertical) {
              stylize(info.element, {
                height: info.h + 'px', right: mxp, bottom: v + 'px', left: mxp
              });
            } else {
              stylize(info.element, {
                top: myp, right: v + 'px', bottom: myp, width: info.w + 'px'
              });
            }
          });
        }
      }
    });
    function stylize(element, styles) {
      var style = element.style;
      Object.keys(styles).forEach(function(k){
        style[k] = styles[k];
      });
    }
  </script>
</polymer-element>

<!--
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
-->
<!--
/**
 * @module Polymer Elements
 */
/**
 * polymer-flex-layout provides a helper to use CSS3 Flexible Boxes.  By putting
 * polymer-flex-layout inside an element it makes the element a flex
 * container. Use 'flex' attribute to make the flex item flexible.
 *
 * Example:
 *
 *     <div>
 *       <polymer-flex-layout></polymer-flex-layout>
 *       <div>Left</div>
 *       <div flex>Main</div>
 *       <div>Right</div>
 *     </div>
 *
 *     ---------------------------------
 *     |-------------------------------|
 *     ||Left|       Main       |Right||
 *     |-------------------------------|
 *     ---------------------------------
 *
 *     <div>
 *       <polymer-flex-layout vertical></polymer-flex-layout>
 *       <div>Header</div>
 *       <div flex>Body</div>
 *       <div>Footer</div>
 *     </div>
 *
 *     ----------
 *     ||------||
 *     ||Header||
 *     ||------||
 *     ||Body  ||
 *     ||      ||
 *     ||      ||
 *     ||      ||
 *     ||      ||
 *     ||      ||
 *     ||      ||
 *     ||------||
 *     ||Footer||
 *     ||------||
 *     ----------
 *
 * @class polymer-flex-layout
 */
/**
 * If true, flex items are aligned vertically.
 *
 * @attribute vertical
 * @type boolean
 * @default false
 */
/**
 * Defines the default for how flex items are laid out along the cross axis on 
 * the current line.  Possible values are 'start', 'center' and 'end'.
 *
 * @attribute align
 * @type string
 * @default ''
 */
/**
 * Defines how flex items are laid out along the main axis on the current line.
 * Possible values are 'start', 'center' and 'end'.
 *
 * @attribute justify
 * @type string
 * @default ''
 */
/**
 * If true, polymer-flex-layout is the flex container.
 *
 * Example:
 *
 *     <polymer-flex-layout isContainer>
 *       <div>Left</div>
 *       <div flex>Main</div>
 *       <div>Right</div>
 *     </polymer-flex-layout>
 *
 *     ---------------------------------
 *     |-------------------------------|
 *     ||Left|       Main       |Right||
 *     |-------------------------------|
 *     ---------------------------------
 *
 * @attribute isContainer
 * @type boolean
 * @default false
 */
-->


<polymer-element name="polymer-flex-layout" attributes="vertical align justify isContainer" assetpath="../polymer-flex-layout/">
  <template>
    <style polymer-scope="controller">/*
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
*/
.flexbox, [flexbox], [h-flexbox], [v-flexbox] {
  display: -webkit-box !important;
  display: -ms-flexbox !important;
  display: -moz-flex !important;
  display: -webkit-flex !important;
  display: flex !important;
}

.flexbox.row, [flexbox], [h-flexbox] {
  -webkit-box-orient: horizontal;
  -ms-flex-direction: row;
  -moz-flex-direction: row;
  -webkit-flex-direction: row;
  flex-direction: row;
}

.flexbox.column, [v-flexbox] {
  -webkit-box-orient: vertical;
  -ms-flex-direction: column;
  -moz-flex-direction: column;
  -webkit-flex-direction: column;
  flex-direction: column;
}

.flex, [flex], [fit] {
  -webkit-box-flex: 1;
  -ms-flex: 1;
  -moz-flex: 1;
  -webkit-flex: 1;
  flex: 1;
}

::-webkit-distributed(.flex), 
::-webkit-distributed([flex]),
::-webkit-distributed([fit]) {
  -webkit-box-flex: 1;
  -ms-flex: 1;
  -moz-flex: 1;
  -webkit-flex: 1;
  flex: 1;
}

.flexbox.align-start {
  -webkit-box-align: start;
  -ms-flex-align: start;
  -moz-align-items: flex-start;
  -webkit-align-items: flex-start;
  align-items: flex-start;
}

.flexbox.align-end {
  -webkit-box-align: end;
  -ms-flex-align: end;
  -moz-align-items: flex-end;
  -webkit-align-items: flex-end;
  align-items: flex-end;
}

.flexbox.align-center {
  -webkit-box-align: center;
  -ms-flex-align: center;
  -moz-align-items: center;
  -webkit-align-items: center;
  align-items: center;
}

.flexbox.justify-start {
  -webkit-box-pack: start;
  -ms-flex-pack: start;
  -moz-justify-content: flex-start;
  -webkit-justify-content: flex-start;
  justify-content: flex-start;
}

.flexbox.justify-end {
  -webkit-box-pack: end;
  -ms-flex-pack: end;
  -moz-justify-content: flex-end;
  -webkit-justify-content: flex-end;
  justify-content: flex-end;
}

.flexbox.justify-center {
  -webkit-box-pack: center;
  -ms-flex-pack: center;
  -moz-justify-content: center;
  -webkit-justify-content: center;
  justify-content: center;
}

.flexbox.justify-between {
  -webkit-box-pack: justify;
  -ms-flex-pack: justify;
  -moz-justify-content: space-between;
  -webkit-justify-content: space-between;
  justify-content: space-between;
}

:host(.flexbox:host, [flexbox]:host, [h-flexbox]:host, [v-flexbox]:host) {
  display: -webkit-box !important;
  display: -ms-flexbox !important;
  display: -moz-flex !important;
  display: -webkit-flex !important;
  display: flex !important;
}
  
:host(.flexbox.row:host, [flexbox]:host, [h-flexbox]:host) {
  -webkit-box-orient: horizontal;
  -ms-flex-direction: row;
  -moz-flex-direction: row;
  -webkit-flex-direction: row;
  flex-direction: row;
}
  
:host(.flexbox.column:host, [v-flexbox]:host) {
  -webkit-box-orient: vertical;
  -ms-flex-direction: column;
  -moz-flex-direction: column;
  -webkit-flex-direction: column;
  flex-direction: column;
}
  
:host(.flexbox.align-start:host) {
  -webkit-box-align: start;
  -ms-flex-align: start;
  -moz-align-items: flex-start;
  -webkit-align-items: flex-start;
  align-items: flex-start;
}
  
:host(.flexbox.align-end:host) {
  -webkit-box-align: end;
  -ms-flex-align: end;
  -moz-align-items: flex-end;
  -webkit-align-items: flex-end;
  align-items: flex-end;
}

:host(.flexbox.align-center:host) {
  -webkit-box-align: center;
  -ms-flex-align: center;
  -moz-align-items: center;
  -webkit-align-items: center;
  align-items: center;
}

:host(.flexbox.justify-start:host) {
  -webkit-box-pack: start;
  -ms-flex-pack: start;
  -moz-justify-content: flex-start;
  -webkit-justify-content: flex-start;
  justify-content: flex-start;
}

:host(.flexbox.justify-end:host) {
  -webkit-box-pack: end;
  -ms-flex-pack: end;
  -moz-justify-content: flex-end;
  -webkit-justify-content: flex-end;
  justify-content: flex-end;
}

:host(.flexbox.justify-center:host) {
  -webkit-box-pack: center;
  -ms-flex-pack: center;
  -moz-justify-content: center;
  -webkit-justify-content: center;
  justify-content: center;
}

:host(.flexbox.justify-between:host) {
  -webkit-box-pack: justify;
  -ms-flex-pack: justify;
  -moz-justify-content: space-between;
  -webkit-justify-content: space-between;
  justify-content: space-between;
}
</style>
    <style>/*
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
*/
.flexbox, [flexbox], [h-flexbox], [v-flexbox] {
  display: -webkit-box !important;
  display: -ms-flexbox !important;
  display: -moz-flex !important;
  display: -webkit-flex !important;
  display: flex !important;
}

.flexbox.row, [flexbox], [h-flexbox] {
  -webkit-box-orient: horizontal;
  -ms-flex-direction: row;
  -moz-flex-direction: row;
  -webkit-flex-direction: row;
  flex-direction: row;
}

.flexbox.column, [v-flexbox] {
  -webkit-box-orient: vertical;
  -ms-flex-direction: column;
  -moz-flex-direction: column;
  -webkit-flex-direction: column;
  flex-direction: column;
}

.flex, [flex], [fit] {
  -webkit-box-flex: 1;
  -ms-flex: 1;
  -moz-flex: 1;
  -webkit-flex: 1;
  flex: 1;
}

::-webkit-distributed(.flex), 
::-webkit-distributed([flex]),
::-webkit-distributed([fit]) {
  -webkit-box-flex: 1;
  -ms-flex: 1;
  -moz-flex: 1;
  -webkit-flex: 1;
  flex: 1;
}

.flexbox.align-start {
  -webkit-box-align: start;
  -ms-flex-align: start;
  -moz-align-items: flex-start;
  -webkit-align-items: flex-start;
  align-items: flex-start;
}

.flexbox.align-end {
  -webkit-box-align: end;
  -ms-flex-align: end;
  -moz-align-items: flex-end;
  -webkit-align-items: flex-end;
  align-items: flex-end;
}

.flexbox.align-center {
  -webkit-box-align: center;
  -ms-flex-align: center;
  -moz-align-items: center;
  -webkit-align-items: center;
  align-items: center;
}

.flexbox.justify-start {
  -webkit-box-pack: start;
  -ms-flex-pack: start;
  -moz-justify-content: flex-start;
  -webkit-justify-content: flex-start;
  justify-content: flex-start;
}

.flexbox.justify-end {
  -webkit-box-pack: end;
  -ms-flex-pack: end;
  -moz-justify-content: flex-end;
  -webkit-justify-content: flex-end;
  justify-content: flex-end;
}

.flexbox.justify-center {
  -webkit-box-pack: center;
  -ms-flex-pack: center;
  -moz-justify-content: center;
  -webkit-justify-content: center;
  justify-content: center;
}

.flexbox.justify-between {
  -webkit-box-pack: justify;
  -ms-flex-pack: justify;
  -moz-justify-content: space-between;
  -webkit-justify-content: space-between;
  justify-content: space-between;
}

:host(.flexbox:host, [flexbox]:host, [h-flexbox]:host, [v-flexbox]:host) {
  display: -webkit-box !important;
  display: -ms-flexbox !important;
  display: -moz-flex !important;
  display: -webkit-flex !important;
  display: flex !important;
}
  
:host(.flexbox.row:host, [flexbox]:host, [h-flexbox]:host) {
  -webkit-box-orient: horizontal;
  -ms-flex-direction: row;
  -moz-flex-direction: row;
  -webkit-flex-direction: row;
  flex-direction: row;
}
  
:host(.flexbox.column:host, [v-flexbox]:host) {
  -webkit-box-orient: vertical;
  -ms-flex-direction: column;
  -moz-flex-direction: column;
  -webkit-flex-direction: column;
  flex-direction: column;
}
  
:host(.flexbox.align-start:host) {
  -webkit-box-align: start;
  -ms-flex-align: start;
  -moz-align-items: flex-start;
  -webkit-align-items: flex-start;
  align-items: flex-start;
}
  
:host(.flexbox.align-end:host) {
  -webkit-box-align: end;
  -ms-flex-align: end;
  -moz-align-items: flex-end;
  -webkit-align-items: flex-end;
  align-items: flex-end;
}

:host(.flexbox.align-center:host) {
  -webkit-box-align: center;
  -ms-flex-align: center;
  -moz-align-items: center;
  -webkit-align-items: center;
  align-items: center;
}

:host(.flexbox.justify-start:host) {
  -webkit-box-pack: start;
  -ms-flex-pack: start;
  -moz-justify-content: flex-start;
  -webkit-justify-content: flex-start;
  justify-content: flex-start;
}

:host(.flexbox.justify-end:host) {
  -webkit-box-pack: end;
  -ms-flex-pack: end;
  -moz-justify-content: flex-end;
  -webkit-justify-content: flex-end;
  justify-content: flex-end;
}

:host(.flexbox.justify-center:host) {
  -webkit-box-pack: center;
  -ms-flex-pack: center;
  -moz-justify-content: center;
  -webkit-justify-content: center;
  justify-content: center;
}

:host(.flexbox.justify-between:host) {
  -webkit-box-pack: justify;
  -ms-flex-pack: justify;
  -moz-justify-content: space-between;
  -webkit-justify-content: space-between;
  justify-content: space-between;
}
</style>
    <content></content>
  </template>
  <script>
    Polymer('polymer-flex-layout', {
      vertical: false,
      isContainer: false,
      layoutContainer: null,
      enteredView: function() {
        this.installControllerStyles();
        this.layoutContainer = this.isContainer ? 
            this : (this.parentNode.host || this.parentNode);
        this.verticalChanged();
        this.alignChanged();
        this.justifyChanged();
      },
      leftView: function() {
        this.layoutContainer = null;
      },
      layoutContainerChanged: function(old) {
        if (old) {
          old.classList.remove('flexbox');
        }
        this.style.display = this.layoutContainer === this ? '' : 'none';
        if (this.layoutContainer) {
          this.layoutContainer.classList.add('flexbox');
        }
      },
      switchContainerClass: function(prefix, old, name) {
        if (this.layoutContainer && name) {
          this.layoutContainer.classList.switch(
              prefix + old, prefix + name);
        }
      },
      verticalChanged: function() {
        if (this.layoutContainer) {
          this.layoutContainer.classList.toggle('column', this.vertical);
        }
      },
      alignChanged: function(old) {
        this.switchContainerClass('align-', old, this.align);
      },
      justifyChanged: function(old) {
        this.switchContainerClass('justify-', old, this.justify);
      }
    });
  </script>
</polymer-element>

<!--
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
-->
<!--
/**
 * @module Polymer Elements
 */
/**
 * polymer-media-query can be used to data bind to a CSS media query.
 * The "query" property is a bare CSS media query.
 * The "queryMatches" property will be a boolean representing if the page matches that media query.
 *
 * polymer-media-query uses media query listeners to dynamically update the "queryMatches" property.
 * A "polymer-mediachange" event also fires when queryMatches changes.
 *
 * Example:
 *
 *      <polymer-media-query query="max-width: 640px" queryMatches="{{phoneScreen}}"></polymer-media-query>
 *
 * @class polymer-media-query
 */
-->


<polymer-element name="polymer-media-query" attributes="query queryMatches" assetpath="../polymer-media-query/">
  <template>
    <style>
      :host {
        display: none;
      }
    </style>
  </template>
  <script>

    Polymer('polymer-media-query', {
      /**
       * The Boolean return value of the media query
       * @attribute queryMatches
       * @type Boolean
       * @default false
       */
      queryMatches: false,
      /**
       * The CSS media query to evaulate
       * @attribute query
       * @type string
       * @default ''
       */
      query: '',
      ready: function() {
        this._mqHandler = this.queryHandler.bind(this);
        this._mq = null;
      },
      queryChanged: function() {
        if (this._mq) {
          this._mq.removeListener(this._mqHandler);
        }
        var query = this.query;
        if (query[0] !== '(') {
          query = '(' + this.query + ')';
        }
        this._mq = window.matchMedia(query);
        this._mq.addListener(this._mqHandler);
        this.queryHandler(this._mq);
      },
      queryHandler: function(mq) {
        this.queryMatches = mq.matches;
        this.asyncFire('polymer-mediachange', mq);
      }
    });
  </script>
</polymer-element>



<polymer-element name="polymer-grid-layout" attributes="nodes layout auto" assetpath="../polymer-grid-layout/">
  <template>
  </template>
  <script>
    (function() {
      Polymer('polymer-grid-layout', {
        nodes: null,
        layout: null,
        auto: false,
        created: function() {
          this.layout = [];
        },
        nodesChanged: function() {
          this.invalidate();
        },
        layoutChanged: function() {
          this.invalidate();
        },
        autoNodes: function() {
          this.nodes = this.parentNode.children.array().filter(
            function(node) {
              switch(node.localName) {
                case 'polymer-grid-layout':
                case 'style':
                  return false;
              }
              return true;
            }
          );
        },
        invalidate: function() {
          if (this.layout && this.layout.length) {
            // job debounces layout, only letting it occur every N ms
            this.layoutJob = this.job(this.layoutJob, this.relayout);
          }
        },
        relayout: function() {
          if (!this.nodes || this.auto) {
            this.autoNodes();
          }
          layout(this.layout, this.nodes);
          this.asyncFire('polymer-grid-layout');
        }
      });

      //

      var lineParent;

      function line(axis, p, d) {
        var l = document.createElement('line');
        var extent = (axis === 'left' ? 'width' : 
          (axis === 'top' ? 'height' : axis));
        l.setAttribute('extent', extent);
        if (d < 0) {
          axis = (axis === 'left' ? 'right' : 
            (axis === 'top' ? 'bottom' : axis));
        }
        p = Math.abs(p);
        l.style[axis] = p + 'px';
        l.style[extent] = '0px';
        lineParent.appendChild(l);
      }

      var colCount, colOwners, rowCount, rowOwners;

      function matrixillate(matrix) {
        // mesaure the matrix, must be rectangular
        rowCount = matrix.length;
        colCount = rowCount && matrix[0].length || 0;
        // transpose matrix
        var transpose = [];
        for (var i=0; i<colCount; i++) {
          var c = [];
          for (var j=0; j<rowCount; j++) {
            c.push(matrix[j][i]);
          }
          transpose.push(c);
        }
        // assign sizing control
        colOwners = findOwners(matrix);
        rowOwners = findOwners(transpose);
        //console.log('colOwners', colOwners);
        //console.log('rowOwners', rowOwners);
      }

      function findOwners(matrix) {
        var majCount = matrix.length;
        var minCount = majCount && matrix[0].length || 0;
        var owners = [];
        // for each column (e.g.)
        for (var i=0; i<minCount; i++) {
          // array of contained areas
          var contained = {};
          // look at each row to find a containing area
          for (var j=0; j<majCount; j++) {
            // get the row vector
            var vector = matrix[j]
            // node index at [i,j]
            var nodei = vector[i];
            // if a node is there
            if (nodei) {
              // determine if it bounds this column
              var owns = false;
              if (i === 0) {
                owns = (i === minCount-1) || (nodei !== vector[i+1]);
              } else if (i === minCount - 1) {
                owns = (i === 0) || (nodei !== vector[i-1]);
              } else {
                owns = nodei !== vector[i-1] && nodei !== vector[i+1];
              }
              if (owns) {
                contained[nodei] = 1;
              }
            }
            // store the owners for this column
            owners[i] = contained;
          }
        }
        return owners;
      }

      var nodes;

      function colWidth(i) {
        for (var col in colOwners[i]) {
          col = Number(col);
          if (col === 0) {
            return 96;
          }
          var node = nodes[col - 1];
          if (node.hasAttribute('h-flex') || node.hasAttribute('flex')) {
            return -1;
          }
          var w = node.offsetWidth;
          //console.log('colWidth(' + i + ') ==', w);
          return w;
        }
        return -1;
      }

      function rowHeight(i) {
        for (var row in rowOwners[i]) {
          row = Number(row);
          if (row === 0) {
            return 96;
          }
          var node = nodes[row - 1];
          if (node.hasAttribute('v-flex') || node.hasAttribute('flex')) {
            return -1;
          }
          var h = node.offsetHeight;
          //console.log('rowHeight(' + i + ') ==', h);
          return h;
        }
        return -1;
      }

      var m = 0;

      function railize(count, sizeFn) {
        //
        // create rails for `count` tracks using 
        // sizing function `sizeFn(trackNo)`
        //
        // for n tracks there are (n+1) rails
        //
        //   |track|track|track|
        //  0|->sz0|->sz1|<-sz2|0
        //
        //   |track|track|track|
        //  0|->sz0|     |<-sz2|0
        //
        // there can be one elastic track per set
        //
        //   |track|track|track|track|
        //  0|-->s0|-->s1|<--s1|<--s2|0
        //
        // sz1 spans multiple  tracks which makes
        // it elastic (it's underconstrained)
        //
        var rails = [];
        var a = 0;
        for (var i=0, x; i<count; i++) {
          rails[i] = {p: a, s: 1};
          x = sizeFn(i) + m + m;
          if (x == -1) {
            break;
          }
          a += x;
        }
        if (i === count) {
          rails[i] = {p: 0, s: -1};
        }
        var b = 0;
        for (var ii=count, x; ii>i; ii--) {
          rails[ii] = {p: b, s: -1};
          x = sizeFn(ii - 1) + m + m;
          if (x !== -1) {
            b += x;
          }
        }
        return rails;
      }

      // TODO(sjmiles): this code tries to preserve actual position,
      // so 'unposition' is really 'naturalize' or something
      function unposition(box) {
        var style = box.style;
        //style.right = style.bottom = style.width = style.height = '';
        style.position = 'absolute';
        style.display = 'inline-block';
        style.boxSizing = style.mozBoxSizing = 'border-box';
      }

      function _position(style, maj, min, ext, a, b) {
        style[maj] = style[min] = '';
        style[ext] = 'auto';
        if (a.s < 0 && b.s < 0) {
          var siz = a.p - b.p - m - m;
          style[ext] = siz + 'px';
          var c = 'calc(100% - ' + (b.p + siz + m) + 'px' + ')';
          style[maj] = '-webkit-' + c;
          style[maj] = c;
        } else if (b.s < 0) {
          style[maj] = a.p + m + 'px';
          style[min] = b.p + m + 'px';
        } else {
          style[maj] = a.p + m + 'px';
          style[ext] = b.p - a.p - m - m + 'px';
        }
      }

      function position(elt, left, right, top, bottom) {
        _position(elt.style, 'top', 'bottom', 'height', rows[top], 
            rows[bottom]);
        _position(elt.style, 'left', 'right', 'width', columns[left], 
            columns[right]);
      }

      function layout(matrix, anodes, alineParent) {
        //console.group('layout');

        lineParent = alineParent;
        nodes = anodes;
        matrixillate(matrix);

        nodes.forEach(unposition);

        columns = railize(colCount, colWidth);
        rows = railize(rowCount, rowHeight);

        if (alineParent) {
          //console.group('column rails');
          columns.forEach(function(c) {
            //console.log(c.p, c.s);
            line('left', c.p, c.s);
          });
          //console.groupEnd();

          //console.group('row rails');
          rows.forEach(function(r) {
            //console.log(r.p, r.s);
            line('top', r.p, r.s);
          });
          //console.groupEnd();
        }

        //console.group('rail boundaries');
        nodes.forEach(function(node, i) {
          // node indices are 1-based
          var n = i + 1;
          // boundary rails
          var l, r, t = 1e10, b = -1e10;
          matrix.forEach(function(vector, i) {
            var f = vector.indexOf(n);
            if (f > -1) {
              l = f;
              r = vector.lastIndexOf(n) + 1;
              t = Math.min(t, i);
              b = Math.max(b, i) + 1;
            }
          });
          if (l == undefined) {
            //console.log('unused');
            node.style.position = 'absolute';
            var offscreen = node.getAttribute('offscreen');
            switch (offscreen) {
              case 'basement':
                node.style.zIndex = 0;
                break;
              case 'left':
              case 'top':
                node.style[offscreen] = node.offsetWidth * -2 + 'px';
                break;
              case 'right':
                node.style.left = node.offsetParent.offsetWidth 
                    + node.offsetWidth + 'px';
                break;
              case 'bottom':
                node.style.top = node.parentNode.offsetHeight 
                    + node.offsetHeight + 'px';
                break;
              default:
                node.style[Math.random() >= 0.5 ? 'left' : 'top'] = '-110%';
            }
            //node.style.opacity = 0;
            node.style.pointerEvents = 'none';
          } else {
            node.style.pointerEvents = '';
            //node.style.opacity = '';
            //console.log(l, r, t, b);
            position(node, l, r, t, b);
          }
        });
        //console.groupEnd();
        //console.groupEnd();
      }

    })();
  </script>
</polymer-element>
<!--
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
-->


<polymer-element name="polymer-ui-theme-aware" attributes="theme" assetpath="../polymer-ui-theme-aware/">
  <script>
    PolymerUI = {
      validateTheme: function() {
        var theme = this.theme;
        var defaultTheme = this.defaultTheme;
        if (!theme) {
          var p = this;
          while (p && !theme) {
            theme = p.getAttribute && p.getAttribute('theme');
            defaultTheme = defaultTheme || p.defaultTheme;
            p = p.parentNode || p.host;
          }
        }
        this.activeTheme = this.theme || theme || defaultTheme;
      }
    };
    Polymer('polymer-ui-theme-aware', {
      defaultTheme: '',
      activeTheme: '',
      validateTheme: PolymerUI.validateTheme,
      enteredView: function() {
        this.validateTheme();
      },
      themeChanged: function() {
        this.activeTheme = this.theme;
      },
      activeThemeChanged: function(old) {
        this.classList.switch(old, this.activeTheme);
      }
    });
  </script>
</polymer-element>

<!--
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
-->
<!--
/**
 * @module Polymer Elements
 */
/**
 * polymer-meta is used to manage metadata.  When an instance of polymer-meta
 * is created, it's automatically registered and add to the metaData storage given an id
 * is set on the element. Use byId() to retrive a specific polymer-meta and
 * the property "list" to retrieve all registered polymer-meta's.
 *
 * @class polymer-meta
 */
-->


<polymer-element name="polymer-meta" attributes="list label type" assetpath="../polymer-meta/">
  <script>
    (function() {
      var SKIP_ID = 'meta';
      var metaData = {}, metaArray = {};

      Polymer('polymer-meta', {
        alwaysPrepare: true,
        type: 'default',
        ready: function() {
          this.idChanged();
        },
        get metaArray() {
          var t = this.type;
          if (!metaArray[t]) {
            metaArray[t] = [];
          }
          return metaArray[t];
        },
        get metaData() {
          var t = this.type;
          if (!metaData[t]) {
            metaData[t] = {};
          }
          return metaData[t];
        },
        idChanged: function(old) {
          if (this.id && this.id !== SKIP_ID) {
            this.unregister(this, old);
            this.metaData[this.id] = this;
            this.metaArray.push(this);
          }
        },
        unregister: function(meta, id) {
          delete this.metaData[id || meta.id];
          var i = this.metaArray.indexOf(meta);
          if (i >= 0) {
            this.metaArray.splice(i, 1);
          }
        },
        get list() {
          return this.metaArray;
        },
        get archetype() {
          return this.querySelector('template');
        },
        byId: function(id) {
          return this.metaData[id];
        },
        get childMetas() {
          return this.querySelectorAll(this.localName);
        }
      });
    })();
  </script>
</polymer-element>

<!--
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
-->

<!--
/**
* Polymer UI Elements
*
* @module Polymer UI Elements
*/  
/**
 * polymer-ui-iconset allows users to define their own icon sets.
 *
 * Example:
 *
 *     <polymer-ui-iconset id="my-icons" src="my-icons.png" width="96" iconsize="24"
 *         icons="location place starta stopb bus car train walk">
 *     </polymer-ui-iconset>
 *
 * The above will automatically register the icon set "my-icons" to the iconset
 * database.  To use the user-defined icon set, prefix the icon with
 * the icon set e.g. "my-icons:clock"
 *
 * Example:
 *
 *     <polymer-ui-icon-button icon="my-icons:car"></polymer-ui-icon-button>
 *
 * @class polymer-ui-iconset
 */
-->


<polymer-element name="polymer-ui-iconset" extends="polymer-meta" attributes="src width icons iconsize" assetpath="../polymer-ui-iconset/">
  <script>
    Polymer('polymer-ui-iconset', {
      width: 0,
      icons: '',
      iconsize: 0,
      offsetx: 0,
      offsety: 0,
      type: 'iconset',
      ready: function() {
        this.super();
        this.iconsChanged();
        this.updateThemes();
      },
      iconsChanged: function() {
        this.iconMap = {};
        var ox = this.offsetx;
        var oy = this.offsety;
        this.icons && this.icons.split(/\s+/g).forEach(function(name, i) {
          this.iconMap[name] = {
            offsetx: ox,
            offsety: oy
          }
          if (ox + this.iconsize < this.width) {
            ox += this.iconsize;
          } else {
            ox = this.offsetx;
            oy += this.iconsize;
          }
        }, this);
      },
      updateThemes: function() {
        this.themes = {};
        var ts = this.querySelectorAll('property[theme]');
        ts && ts.array().forEach(function(t) {
          this.themes[t.getAttribute('theme')] = {
            offsetx: parseInt(t.getAttribute('offsetx')) || 0,
            offsety: parseInt(t.getAttribute('offsety')) || 0
          };
        }, this);
      },
      // TODO(ffu): support retrived by index e.g. getOffset(10);
      getOffset: function(icon, theme) {
        var i = this.iconMap[icon];
        var t = this.themes[theme];
        if (i && t) {
          return {
            offsetx: i.offsetx + t.offsetx,
            offsety: i.offsety + t.offsety
          }
        }
        return i;
      }
    });
  </script>
</polymer-element>
<!--
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
-->

<polymer-ui-iconset id="polymer-ui-icons" src="../polymer-ui-icon/action-icons.png" width="24" iconsize="24" icons="drawer menu search dropdown close add trash refresh settings dialoga 
           left right down up grid contact account plus time marker 
           briefcase array columns list modules quilt stream maximize shrink sort 
           shortcut dialog twitter facebook favorite gplus filter tag plusone dots">

  <property theme="polymer-ui-light-theme" offsetx="24"></property>
  <property theme="polymer-ui-dark-theme" offsetx="72"></property>
</polymer-ui-iconset>
<!--
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
-->

<!--
/**
* Polymer UI Elements
*
* @module Polymer UI Elements
*/  
/**
 * polymer-ui-icon is a 24x24 glyph expressed as a background-image.
 *
 * Example:
 *
 *     <polymer-ui-icon src="star.png"></polymer-ui-icon>
 *
 * Optionally can use other size like 32x32 by setting the attribute "size" to "32":
 *
 *     <polymer-ui-icon src="big_star.png" size="32"></polymer-ui-icon>
 *
 * Polymer includes an icon set.  The property "icon" can be used
 * to specify which icon to use.
 *
 * Example:
 *
 *     <polymer-ui-icon icon="menu"></polymer-ui-icon>
 *
 * See <a href="polymer-ui-iconset.html">polymer-ui-iconset</a> on how to use
 * your own icon set.
 *
 * @class polymer-ui-icon
 */
-->





<polymer-element name="polymer-ui-icon" extends="polymer-ui-theme-aware" attributes="src size index icon" assetpath="../polymer-ui-icon/">
  <template>
    <style>/*
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
*/

:host {
  display: inline-block;
  vertical-align: middle;
  cursor: pointer;
  background-repeat: no-repeat;
}
</style>
    <polymer-ui-iconset id="meta"></polymer-ui-iconset>
    <content></content>
  </template>
  <script>
    Polymer('polymer-ui-icon', {
      /**
       * The URL of an image for the icon.
       *
       * @attribute src
       * @type string
       * @default ''
       */
      src: '',
      /**
       * Specifies the size of the icon.
       *
       * @attribute size
       * @type string
       * @default 24
       */
      size: 24,
      /**
       * Specifies the icon from the icon set.
       *
       * @attribute icon
       * @type string
       * @default ''
       */
      icon: '',
      defaultIconset: 'polymer-ui-icons',
      observe: {
        icon: 'updateIcon',
        activeTheme: 'updateIcon'
      },
      ready: function() {
        this.sizeChanged();
      },
      sizeChanged: function() {
        this.style.width = this.style.height = this.size + 'px';
      },
      srcChanged: function() {
        this.style.backgroundImage = 'url(' + this.src + ')';
        this.style.backgroundPosition = 'center';
        this.style.backgroundSize = this.size + 'px ' + this.size + 'px';
      },
      getIconset: function(name) {
        return this.$.meta.byId(name || this.defaultIconset);
      },
      updateIcon: function() {
        if (!this.icon) {
          return;
        }
        var a = this.icon.split(':');
        var icon = a.pop();
        var n = a.pop();
        var s = this.getIconset(n);
        if (s) {
          var o = s.getOffset(icon, this.activeTheme);
          if (o) {
            var r = this.size / s.iconsize;
            this.style.backgroundImage = 'url(' + s.src + ')';
            this.style.backgroundPosition = 
                (-o.offsetx * r + 'px') + ' ' + (-o.offsety * r + 'px');
            this.style.backgroundSize = r === 1 ? 'auto' : s.width * r + 'px';
          }
        }
      }
    });
  </script>
</polymer-element>

<!--
Copyright 2013 The Toolkitchen Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
-->
<!--
/**
 * @module Polymer UI Elements
 */
/**
 * polymer-ui-menu-item is styled to look like a menu item.  It should be used
 * in conjunction with polymer-ui-menu or polymer-ui-sibebar-menu.
 *
 * Example:
 *
 *     <polymer-ui-menu-item icon="settings" label="Settings"></polymer-ui-menu-item>
 *
 * @class polymer-ui-menu-item
 */
/**
 * The URL of an image for the icon.
 *
 * @attribute src
 * @type string
 * @default ''
 */
/**
 * Specifies the icon from the Polymer icon set.
 *
 * @attribute icon
 * @type string
 * @default ''
 */
/**
 * Specifies the label for the menu item.
 *
 * @attribute label
 * @type string
 * @default ''
 */
/**
 * Specifies the URL of the link it goes to when tapped on.
 *
 * Example:
 *
 *     <polymer-ui-menu-item icon="favorite" label="Favorite" href="http://www.polymer-project.org/"></polymer-ui-menu-item>
 *
 * If you want more control on the link, e.g. specify the target for where to
 * open the linked document, you can put &lt;a> directly inside the menu-item.
 *
 * Example:
 *
 *     <polymer-ui-menu-item icon="favorite" label="Favorite">
 *       <a href="http://www.polymer-project.org/" target="_self"></a>
 *     </polymer-ui-menu-item>
 *
 * @attribute href
 * @type string
 * @default ''
 */
-->




<polymer-element name="polymer-ui-menu-item" extends="polymer-ui-theme-aware" attributes="src label icon item href" assetpath="../polymer-ui-menu-item/">
  <template>
    <style>/*
Copyright 2013 The Toolkitchen Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
*/

:host { 
  display: block;
  position: relative;
  box-sizing: border-box;
  -moz-box-sizing: border-box;
  height: 40px;
  line-height: 35px;
  font-size: 16px;
  padding: 0 10px;
  border: 1px solid transparent;
  border-radius: 3px;
  white-space: nowrap;
  cursor: pointer;
  opacity: 0.5;
}

:host(:hover:host) {
  opacity: 0.9;
}

:host(.polymer-selected:host, [active]:host) {
  opacity: 1;
}

:host(.polymer-ui-light-theme.polymer-selected:host, .polymer-ui-light-theme[active]:host) {
  background: #f2f2f2;
  border: 1px solid rgba(0, 0, 0, 0.15);
}

:host(.polymer-ui-dark-theme:host) {
  color: #b3b3b3;
}
	
:host(.polymer-ui-dark-theme:hover:host) {
  color: rgba(255, 255, 255, 0.9);
}

:host(.polymer-ui-dark-theme.polymer-selected:host, .polymer-ui-dark-theme[active]:host) {
  background-color: #000;
  border: 1px solid rgba(255, 255, 255, 0.2);
  color: rgba(255, 255, 255, 0.9);
}

:host([active].no-active-bg:host) {
  background-color: transparent;
  border: 1px solid transparent;
}

/* icon and label */
polymer-ui-icon:not([showing]) {
  display: none !important;
}

polymer-ui-icon {
  margin-right: 16px;
}

#label {
  vertical-align: middle;
  padding-right: 20px;
}

/*@polyfill :host #label > a, #link */
::content > a, #link {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  margin: -1px;
}

#link[hidden] {
  display: none;
}
</style>
    <polymer-ui-icon src="{{src}}" icon="{{icon}}" showing?="{{icon || src}}"></polymer-ui-icon>
    <span id="label">{{label}}<content></content></span>
    <a id="link" href="{{href}}" hidden?="{{!href}}"></a>
  </template>
  <script>
    Polymer('polymer-ui-menu-item', {
      label: '',
      // calc item's offset middle pos instead of using offsetTop/Height 
      // directly which requires to wait for submenu's collapsing transition to 
      // complete first before it can return the correct pos.
      getOffsetMiddle: function() {
        var p = this.parentNode;
        if (p) {
          var i = Array.prototype.indexOf.call(p.items, this);
          var h = this.getItemHeight();
          return i * h + h/2 + p.items[0].offsetTop;
        }
      },
      getItemHeight: function() {
        return this.offsetHeight;
      }
    });
  </script>
</polymer-element>

<!--
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
-->
<!--
/**
 * @module Polymer Elements
 */
-->
<!--
/**
 * The polymer-selection element is used to manage selection state. It has no
 * visual appearance and is typically used in conjuneciton with another element.
 * For example, <a href="polymer-selector.html">polymer-selector</a>
 * use a polymer-selection to manage selection.
 *
 * To mark an item as selected, call the select(item) method on 
 * polymer-selection. Notice that the item itself is an argument to this method.
 * The polymer-selection element manages selection state for any given set of
 * items. When an item is selected, the `polymer-select` event is fired.
 * The attribute "multi" indicates if multiple items can be selected at once.
 * 
 * Example:
 *
 *     <polymer-element name="selection-example">
 *        <template>
 *          <style>
 *            ::-webkit-distributed(> .selected) {
 *              font-weight: bold;
 *              font-style: italic;
 *            }
 *          </style>
 *          <ul on-tap="{{itemTapAction}}">
 *            <content></content>
 *          </ul>
 *          <polymer-selection id="selection" multi on-polymer-select="{{selectAction}}"></polymer-selection>
 *        </template>
 *        <script>
 *          Polymer('selection-example', {
 *            itemTapAction: function(e) {
 *              this.$.selection.select(e.target);
 *            },
 *            selectAction: function(e, detail) {
 *              detail.item.classList.toggle('selected', detail.isSelected);
 *            }
 *          });
 *        </script>
 *     </polymer-element>
 *
 *     <selection-example>
 *       <li>Red</li>
 *       <li>Green</li>
 *       <li>Blue</li>
 *     </selection-example>
 *
 * @class polymer-selection
 */
 /**
 * Fired when an item's selection state is changed. This event is fired both
 * when an item is selected or deselected. The `isSelected` detail property
 * contains the selection state.
 * 
 * @event polymer-select
 * @param {Object} detail
 *   @param {boolean} detail.isSelected true for selection and false for deselection
 *   @param {Object} detail.item the item element
 */
-->


<polymer-element name="polymer-selection" attributes="multi" assetpath="../polymer-selection/">
  <template>
    <style>
      :host {
        display: none !important;
      }
    </style>
  </template>
  <script>
    Polymer('polymer-selection', {
      /**
       * If true, multiple selections are allowed.
       *
       * @attribute multi
       * @type boolean
       * @default false
       */
      multi: false,
      ready: function() {
        this.clear();
      },
      clear: function() {
        this.selection = [];
      },
      /**
       * Retrieves the selected item(s).
       * @method getSelection
       * @returns Returns the selected item(s). If the multi property is true,
       * getSelection will return an array, otherwise it will return 
       * the selected item or undefined if there is no selection.
      */
      getSelection: function() {
        return this.multi ? this.selection : this.selection[0];
      },
      /**
       * Indicates if a given item is selected.
       * @method isSelected
       * @param {any} item The item whose selection state should be checked.
       * @returns Returns true if `item` is selected.
      */
      isSelected: function(item) {
        return this.selection.indexOf(item) >= 0;
      },
      setItemSelected: function(item, isSelected) {
        if (item !== undefined && item !== null) {
          if (isSelected) {
            this.selection.push(item);
          } else {
            var i = this.selection.indexOf(item);
            if (i >= 0) {
              this.selection.splice(i, 1);
            }
          }
          this.fire("polymer-select", {isSelected: isSelected, item: item});
        }
      },
      /**
       * Set the selection state for a given `item`. If the multi property
       * is true, then the selected state of `item` will be toggled; otherwise
       * the `item` will be selected.
       * @method select
       * @param {any} item: The item to select.
      */
      select: function(item) {
        if (this.multi) {
          this.toggle(item);
        } else if (this.getSelection() !== item) {
          this.setItemSelected(this.getSelection(), false);
          this.setItemSelected(item, true);
        }
      },
      /**
       * Toggles the selection state for `item`.
       * @method toggle
       * @param {any} item: The item to toggle.
      */
      toggle: function(item) {
        this.setItemSelected(item, !this.isSelected(item));
      }
    });
  </script>
</polymer-element>

<!--
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
-->
<!--
/**
 * @module Polymer Elements
 */
/**
 * polymer-selector is used to manage a list of elements that can be selected.
 * The attribute "selected" indicates which item element is being selected.
 * The attribute "multi" indicates if multiple items can be selected at once.
 * Tapping on the item element would fire "polymer-activate" event. Use
 * "polymer-select" event to listen for selection changes.
 *
 * Example:
 *
 *     <polymer-selector selected="0">
 *       <div>Item 1</div>
 *       <div>Item 2</div>
 *       <div>Item 3</div>
 *     </polymer-selector>
 *
 * polymer-selector is not styled.  So one needs to use "polymer-selected" CSS
 * class to style the selected element.
 * 
 *     <style>
 *       .item.polymer-selected {
 *         background: #eee;
 *       }
 *     </style>
 *     ...
 *     <polymer-selector>
 *       <div class="item">Item 1</div>
 *       <div class="item">Item 2</div>
 *       <div class="item">Item 3</div>
 *     </polymer-selector>
 *
 * @class polymer-selector
 */
/**
 * Fired when an item's selection state is changed. This event is fired both
 * when an item is selected or deselected. The `isSelected` detail property
 * contains the selection state.
 * 
 * @event polymer-select
 * @param {Object} detail
 *   @param {boolean} detail.isSelected true for selection and false for deselection
 *   @param {Object} detail.item the item element
 */
/**
 * Fired when an item element is tapped.
 * 
 * @event polymer-activate
 * @param {Object} detail
 *   @param {Object} detail.item the item element
 */
-->



<polymer-element name="polymer-selector" attributes="selected multi valueattr selectedClass selectedProperty selectedItem selectedModel selectedIndex notap target itemsSelector activateEvent" assetpath="../polymer-selector/">
  <template>
    <polymer-selection id="selection" multi="{{multi}}" on-polymer-select="{{selectionSelect}}"></polymer-selection>
    <content id="items" select="*"></content>
  </template>
  <script>
    Polymer('polymer-selector', {
      /**
       * Gets or sets the selected element.  Default to use the index
       * of the item element.
       *
       * If you want a specific attribute value of the element to be
       * used instead of index, set "valueattr" to that attribute name.
       *
       * Example:
       *
       *     <polymer-selector valueattr="label" selected="foo">
       *       <div label="foo"></div>
       *       <div label="bar"></div>
       *       <div label="zot"></div>
       *     </polymer-selector>
       *
       * In multi-selection this should be an array of values.
       *
       * Example:
       *
       *     <polymer-selector id="selector" valueattr="label" multi>
       *       <div label="foo"></div>
       *       <div label="bar"></div>
       *       <div label="zot"></div>
       *     </polymer-selector>
       *
       *     this.$.selector.selected = ['foo', 'zot'];
       *
       * @attribute selected
       * @type Object
       * @default null
       */
      selected: null,
      /**
       * If true, multiple selections are allowed.
       *
       * @attribute multi
       * @type boolean
       * @default false
       */
      multi: false,
      /**
       * Specifies the attribute to be used for "selected" attribute.
       *
       * @attribute valueattr
       * @type string
       * @default 'name'
       */
      valueattr: 'name',
      /**
       * Specifies the CSS class to be used to add to the selected element.
       * 
       * @attribute selectedClass
       * @type string
       * @default 'polymer-selected'
       */
      selectedClass: 'polymer-selected',
      /**
       * Specifies the property to be used to set on the selected element
       * to indicate its active state.
       *
       * @attribute selectedProperty
       * @type string
       * @default 'active'
       */
      selectedProperty: 'active',
      /**
       * Returns the currently selected element. In multi-selection this returns
       * an array of selected elements.
       * 
       * @attribute selectedItem
       * @type Object
       * @default null
       */
      selectedItem: null,
      /**
       * In single selection, this returns the model associated with the
       * selected element.
       * 
       * @attribute selectedModel
       * @type Object
       * @default null
       */
      selectedModel: null,
      /**
       * In single selection, this returns the selected index.
       *
       * @attribute selectedIndex
       * @type number
       * @default -1
       */
      selectedIndex: -1,
      /**
       * The target element that contains items.  If this is not set 
       * polymer-selector is the container.
       * 
       * @attribute target
       * @type Object
       * @default null
       */
      target: null,
      /**
       * This can be used to query nodes from the target node to be used for 
       * selection items.  Note this only works if the 'target' property is set.
       *
       * Example:
       *
       *     <polymer-selector target="{{$.myForm}}" itemsSelector="input[type=radio]"></polymer-selector>
       *     <form id="myForm">
       *       <label><input type="radio" name="color" value="red"> Red</label> <br>
       *       <label><input type="radio" name="color" value="green"> Green</label> <br>
       *       <label><input type="radio" name="color" value="blue"> Blue</label> <br>
       *       <p>color = {{color}}</p>
       *     </form>
       * 
       * @attribute itemSelector
       * @type string
       * @default ''
       */
      itemsSelector: '',
      /**
       * The event that would be fired from the item element to indicate
       * it is being selected.
       *
       * @attribute activateEvent
       * @type string
       * @default 'tap'
       */
      activateEvent: 'tap',
      notap: false,
      ready: function() {
        this.activateListener = this.activateHandler.bind(this);
        this.observer = new MutationObserver(this.updateSelected.bind(this));
        if (!this.target) {
          this.target = this;
        }
      },
      get items() {
        var nodes = this.target !== this ? (this.itemsSelector ? 
            this.target.querySelectorAll(this.itemsSelector) : 
                this.target.children) : this.$.items.getDistributedNodes();
        return Array.prototype.filter.call(nodes || [], function(n) {
          return n && n.localName !== 'template';
        });
      },
      targetChanged: function(old) {
        if (old) {
          this.removeListener(old);
          this.observer.disconnect();
        }
        if (this.target) {
          this.addListener(this.target);
          this.observer.observe(this.target, {childList: true});
        }
      },
      addListener: function(node) {
        node.addEventListener(this.activateEvent, this.activateListener);
      },
      removeListener: function(node) {
        node.removeEventListener(this.activateEvent, this.activateListener);
      },
      get selection() {
        return this.$.selection.getSelection();
      },
      selectedChanged: function() {
        this.updateSelected();
      },
      updateSelected: function() {
        this.validateSelected();
        if (this.multi) {
          this.clearSelection();
          this.selected && this.selected.forEach(function(s) {
            this.valueToSelection(s);
          }, this);
        } else {
          this.valueToSelection(this.selected);
        }
      },
      validateSelected: function() {
        // convert to an array for multi-selection
        if (this.multi && !Array.isArray(this.selected) && 
            this.selected !== null && this.selected !== undefined) {
          this.selected = [this.selected];
        }
      },
      clearSelection: function() {
        if (this.multi) {
          this.selection.slice().forEach(function(s) {
            this.$.selection.setItemSelected(s, false);
          }, this);
        } else {
          this.$.selection.setItemSelected(this.selection, false);
        }
        this.selectedItem = null;
        this.$.selection.clear();
      },
      valueToSelection: function(value) {
        var item = (value === null || value === undefined) ? 
            null : this.items[this.valueToIndex(value)];
        this.$.selection.select(item);
      },
      updateSelectedItem: function() {
        this.selectedItem = this.selection;
      },
      selectedItemChanged: function() {
        if (this.selectedItem) {
          var t = this.selectedItem.templateInstance;
          this.selectedModel = t ? t.model : undefined;
        } else {
          this.selectedModel = null;
        }
        this.selectedIndex = this.selectedItem ? 
            parseInt(this.valueToIndex(this.selected)) : -1;
      },
      valueToIndex: function(value) {
        // find an item with value == value and return it's index
        for (var i=0, items=this.items, c; (c=items[i]); i++) {
          if (this.valueForNode(c) == value) {
            return i;
          }
        }
        // if no item found, the value itself is probably the index
        return value;
      },
      valueForNode: function(node) {
        return node[this.valueattr] || node.getAttribute(this.valueattr);
      },
      // events fired from <polymer-selection> object
      selectionSelect: function(e, detail) {
        this.updateSelectedItem();
        if (detail.item) {
          this.applySelection(detail.item, detail.isSelected)
        }
      },
      applySelection: function(item, isSelected) {
        if (this.selectedClass) {
          item.classList.toggle(this.selectedClass, isSelected);
        }
        if (this.selectedProperty) {
          item[this.selectedProperty] = isSelected;
        }
      },
      // event fired from host
      activateHandler: function(e) {
        if (!this.notap) {
          var i = this.findDistributedTarget(e.target, this.items);
          if (i >= 0) {
            var item = this.items[i];
            var s = this.valueForNode(item) || i;
            if (this.multi) {
              if (this.selected) {
                this.addRemoveSelected(s);
              } else {
                this.selected = [s];
              }
            } else {
              this.selected = s;
            }
            this.asyncFire('polymer-activate', {item: item});
          }
        }
      },
      addRemoveSelected: function(value) {
        var i = this.selected.indexOf(value);
        if (i >= 0) {
          this.selected.splice(i, 1);
        } else {
          this.selected.push(value);
        }
        this.valueToSelection(value);
      },
      findDistributedTarget: function(target, nodes) {
        // find first ancestor of target (including itself) that
        // is in nodes, if any
        while (target && target != this) {
          var i = Array.prototype.indexOf.call(nodes, target);
          if (i >= 0) {
            return i;
          }
          target = target.parentNode;
        }
      }
    });
  </script>
</polymer-element>

<!--
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
-->
<!--
/**
 * @module Polymer UI Elements
 */
/**
 * polymer-ui-menu is a polymer-selector with theme propagation.  It styles to look like 
 * a menu and should be used in conjunction with polymer-ui-menu-item.
 *
 * Example:
 * 
 *     <polymer-ui-menu selected="0">
 *       <polymer-ui-menu-item icon="settings" label="Settings"></polymer-ui-menu-item>
 *       <polymer-ui-menu-item icon="dialog" label="Dialog"></polymer-ui-menu-item>
 *       <polymer-ui-menu-item icon="search" label="Search"></polymer-ui-menu-item>
 *     </polymer-ui-menu>
 *
 * The "selectedItem" property returns the currently selected item.
 *
 * Example:
 *
 *     <polymer-ui-menu selected="0" selectedItem="{{item}}">
 *       <polymer-ui-menu-item icon="settings" label="Settings"></polymer-ui-menu-item>
 *       <polymer-ui-menu-item icon="dialog" label="Dialog"></polymer-ui-menu-item>
 *       <polymer-ui-menu-item icon="search" label="Search"></polymer-ui-menu-item>
 *     </polymer-ui-menu>
 *
 *     <div>selected label: {{item.label}}</div>
 *
 * The event "polymer-select" can also be used to listen for selection change.
 *
 * Example:
 *
 *     <polymer-ui-menu selected="0" on-polymer-select="{{selectAction}}">
 *       <polymer-ui-menu-item icon="settings" label="Settings"></polymer-ui-menu-item>
 *       <polymer-ui-menu-item icon="dialog" label="Dialog"></polymer-ui-menu-item>
 *       <polymer-ui-menu-item icon="search" label="Search"></polymer-ui-menu-item>
 *     </polymer-ui-menu>
 *
 *     ...
 *
 *     selectAction: function(e, detail) {
 *       if (detail.isSelected) {
 *         var selectedItem = detail.item;
 *         ...
 *       }
 *     }
 *
 * @class polymer-ui-menu
 * @extends polymer-selector
 */
-->




<polymer-element name="polymer-ui-menu" extends="polymer-selector" attributes="theme" on-polymer-select="{{selectionChange}}" assetpath="../polymer-ui-menu/">
  <template>
    <style>/*
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
*/

:host {
  /* technical */
  display: block;
  box-sizing: border-box;
  -moz-box-sizing: border-box;
  /* size */
  padding: 0.4em;
  font-weight: bold;
}

:host(.polymer-ui-light-theme:host) {
  color: #333333;
}

:host(.polymer-ui-dark-theme:host) {
  background: -webkit-linear-gradient(-60deg, #3d3d3d, #353535);
  background: -moz-linear-gradient(-60deg, #3d3d3d, #353535);
  background: -ms-linear-gradient(-60deg, #3d3d3d, #353535);
  color: #ededed;
}
</style>
    <shadow></shadow>
  </template>
  <script>
    Polymer('polymer-ui-menu', {
      activeTheme: '',
      validateTheme: PolymerUI.validateTheme,
      enteredView: function() {
        this.validateTheme();
      },
      themeChanged: function() {
        this.activeTheme = this.theme;
      },
      activeThemeChanged: function(old) {
        this.classList.switch(old, this.activeTheme);
      },
      selectionChange: function(e, detail) {
        if (detail.isSelected) {
          var i = detail.item;
          // find nested selected item
          while (i.selectedItem) {
            i = i.selectedItem;
          }
          this.selectedItem = i;
        }
      }
    });
  </script>
</polymer-element>

<!--
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
-->
<!--
/**
 * @module Polymer Elements
 */
/**
 * polymer-collapse is used to add collapsible behavior to the
 * target element.  It adjusts the height or width of the target element
 * to make the element collapse and expand.
 *
 * Example:
 *
 *     <button on-click="{{toggle}}">toggle collapse</button>
 *     <div id="demo">
 *       ...
 *     </div>
 *     <polymer-collapse id="collapse" targetId="demo"></polymer-collapse>
 *
 *     ...
 *
 *     toggle: function() {
 *       this.$.collapse.toggle();
 *     }
 *
 * @class polymer-collapse
 */
-->


<polymer-element name="polymer-collapse" attributes="targetId target horizontal closed duration fixedSize size" assetpath="../polymer-collapse/">
  <template>
    <style polymer-scope="controller">/*
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
*/
.polymer-collapse-closed {
  display: none;
}</style>
    <style>/*
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
*/
.polymer-collapse-closed {
  display: none;
}</style>
    <style>
      :host {
        display: none;
      }
    </style>
  </template>
  <script>
    Polymer('polymer-collapse', {
      /**
       * The id of the target element.
       *
       * @attribute targetId
       * @type string
       * @default ''
       */
      targetId: '',
      /**
       * The target element.
       *
       * @attribute target
       * @type object
       * @default null
       */
      target: null,
      /**
       * If true, the orientation is horizontal; otherwise is vertical.
       *
       * @attribute horizontal
       * @type boolean
       * @default false
       */
      horizontal: false,
      /**
       * If true, the target element is hidden/collapsed.
       *
       * @attribute closed
       * @type boolean
       * @default false
       */
      closed: false,
      /**
       * Collapsing/expanding animation duration in second.
       *
       * @attribute duration
       * @type number
       * @default 0.33
       */
      duration: 0.33,
      /**
       * If true, the size of the target element is fixed and is set
       * on the element.  Otherwise it will try to 
       * use auto to determine the natural size to use
       * for collapsing/expanding.
       *
       * @attribute fixedSize
       * @type boolean
       * @default false
       */
      fixedSize: false,
      size: null,
      enteredView: function() {
        this.installControllerStyles();
        this.inDocument = true;
        this.async(function() {
          this.afterInitialUpdate = true;
        });
      },
      leftView: function() {
        this.removeListeners(this.target);
      },
      targetIdChanged: function() {
        var p = this.parentNode;
        while (p.parentNode) {
          p = p.parentNode;
        }
        this.target = p.querySelector('#' + this.targetId);
      },
      targetChanged: function(old) {
        if (old) {
          this.removeListeners(old);
        }
        this.horizontalChanged();
        this.isTargetReady = !!this.target;
        if (this.target) {
          this.target.style.overflow = 'hidden';
          this.addListeners(this.target);
          // set polymer-collapse-closed class initially to hide the target
          this.toggleClosedClass(true);
        }
        // don't need to update if the size is already set and it's opened
        if (!this.fixedSize || !this.closed) {
          this.update();
        }
      },
      addListeners: function(node) {
        this.transitionEndListener = this.transitionEndListener || 
            this.transitionEnd.bind(this);
        node.addEventListener('webkitTransitionEnd', this.transitionEndListener);
        node.addEventListener('transitionend', this.transitionEndListener);
      },
      removeListeners: function(node) {
        node.removeEventListener('webkitTransitionEnd', this.transitionEndListener);
        node.removeEventListener('transitionend', this.transitionEndListener);
      },
      horizontalChanged: function() {
        this.dimension = this.horizontal ? 'width' : 'height';
      },
      closedChanged: function() {
        this.update();
      },
      /** 
       * Toggle the closed state of the collapsible.
       *
       * @method toggle
       */
      toggle: function() {
        this.closed = !this.closed;
      },
      setTransitionDuration: function(duration) {
        var s = this.target.style;
        s.webkitTransition = s.transition = duration ? 
            (this.dimension + ' ' + duration + 's') : null;
        if (duration === 0) {
          this.async('transitionEnd');
        }
      },
      transitionEnd: function() {
        if (!this.closed && !this.fixedSize) {
          this.updateSize('auto', null);
        }
        this.setTransitionDuration(null);
        this.toggleClosedClass(this.closed);
      },
      toggleClosedClass: function(add) {
        this.hasClosedClass = add;
        this.target.classList.toggle('polymer-collapse-closed', add);
      },
      updateSize: function(size, duration, forceEnd) {
        if (duration) {
          this.calcSize();
        }
        this.setTransitionDuration(duration);
        var s = this.target.style;
        var nochange = s[this.dimension] === size;
        s[this.dimension] = size;
        // transitonEnd will not be called if the size has not changed
        if (forceEnd && nochange) {
          this.transitionEnd();
        }
      },
      update: function() {
        if (!this.target || !this.inDocument) {
          return;
        }
        if (!this.isTargetReady) {
          this.targetChanged(); 
        }
        this.horizontalChanged();
        this[this.closed ? 'hide' : 'show']();
      },
      calcSize: function() {
        return this.target.getBoundingClientRect()[this.dimension] + 'px';
      },
      getComputedSize: function() {
        return getComputedStyle(this.target)[this.dimension];
      },
      show: function() {
        this.toggleClosedClass(false);
        // for initial update, skip the expanding animation to optimize
        // performance e.g. skip calcSize
        if (!this.afterInitialUpdate) {
          this.transitionEnd();
          return;
        }
        if (!this.fixedSize) {
          this.updateSize('auto', null);
          var s = this.calcSize();
          this.updateSize(0, null);
        }
        this.async(function() {
          this.updateSize(this.size || s, this.duration, true);
        });
      },
      hide: function() {
        // don't need to do anything if it's already hidden
        if (this.hasClosedClass && !this.fixedSize) {
          return;
        }
        if (this.fixedSize) {
          // save the size before hiding it
          this.size = this.getComputedSize();
        } else {
          this.updateSize(this.calcSize(), null);
        }
        this.async(function() {
          this.updateSize(0, this.duration);
        });
      }
    });
  </script>
</polymer-element>

<!--
Copyright 2013 The Toolkitchen Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
-->
<!--
/**
 * @module Polymer UI Elements
 */
/**
 * polymer-ui-submenu-item is a menu-item that can contains other menu-items.
 * It should be used in conjunction with polymer-ui-menu or 
 * polymer-ui-sibebar-menu.
 *
 * Example:
 *
 *     <polymer-ui-menu selected="0">
 *       <polymer-ui-submenu-item icon="settings" label="Topics">
 *         <polymer-ui-menu-item label="Topics 1"></polymer-ui-menu-item>
 *         <polymer-ui-menu-item label="Topics 2"></polymer-ui-menu-item>
 *       </polymer-ui-submenu-item>
 *       <polymer-ui-submenu-item icon="settings" label="Favorites">
 *         <polymer-ui-menu-item label="Favorites 1"></polymer-ui-menu-item>
 *         <polymer-ui-menu-item label="Favorites 2"></polymer-ui-menu-item>
 *         <polymer-ui-menu-item label="Favorites 3"></polymer-ui-menu-item>
 *       </polymer-ui-submenu-item>
 *     </polymer-ui-menu>
 *
 * @class polymer-ui-submenu-item
 * @extends polymer-ui-menu-item
 */
-->






<polymer-element name="polymer-ui-submenu-item" extends="polymer-ui-menu-item" attributes="active selected selectedItem" assetpath="../polymer-ui-submenu-item/">
  <template>
    <style>/*
Copyright 2013 The Toolkitchen Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
*/

:host { 
  display: block;
}

/* menu */
#menu {
  margin-left: 44px;
  height: 0;
  /* override :host style on polymer-ui-menu */
  background-image: none !important;
  padding: 0 !important;
}
</style>
    <polymer-ui-menu-item id="item" src="{{src}}" label="{{label}}" icon="{{icon}}" active?="{{active}}" on-tap="{{activate}}">
      <content select=".item-content"></content>
    </polymer-ui-menu-item>
    <polymer-ui-menu id="menu" selected="{{selected}}" selecteditem="{{selectedItem}}">
      <content></content>
    </polymer-ui-menu>
    <polymer-collapse targetid="menu" closed="{{collapsed}}"></polymer-collapse>
  </template>
  <script>
    Polymer('polymer-ui-submenu-item', {
      active: false,
      collapsed: true,
      get items() {
        return this.$.menu.items;
      },
      hasItems: function() {
        return !!this.items.length;
      },
      unselectAllItems: function() {
        this.$.menu.selected = null;
        this.$.menu.clearSelection();
      },
      activeChanged: function() {
        if (this.hasItems()) {
          this.collapsed = !this.active;
        }
        if (!this.active) {
          this.unselectAllItems();
        }
        this.$.item.classList.toggle('no-active-bg', this.hasItems());
      },
      activate: function() {
        if (this.hasItems() && this.active) {
          this.collapsed = !this.collapsed;
          this.unselectAllItems();
          this.fire("polymer-select", {isSelected: true, item: this});
        }
      },
      getItemHeight: function() {
        return this.$ && this.$.item && this.$.item.offsetHeight;
      }
    });
  </script>
</polymer-element>

<!--
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
-->

<!--
/**
 * @module Polymer UI Elements
 */
/**
 * polymer-ui-toolbar is a horizontal bar containing elements that can perform actions.
 *
 * Example:
 *
 *     <polymer-ui-toolbar>
 *       <polymer-ui-icon-button src="menu.png" on-click="{{menuAction}}"></polymer-ui-icon-button>
 *       <div flex>Title</div>
 *       <polymer-ui-icon-button src="more.png" on-click="{{moreAction}}"></polymer-ui-icon-button>
 *     </polymer-ui-toolbar>
 *
 * polymer-ui-toolbar can adopt to smaller screen size.  If the attribute "responsive" is set
 * and the screen size is less than the responsiveWidth (default to 800px), the toolbar will
 * be moved to the bottom of the page.
 *
 * Example:
 *
 *     <polymer-ui-toolbar>
 *       <polymer-ui-icon-button icon="menu"></polymer-ui-icon-button>
 *       <div flex>Title</div>
 *       <polymer-ui-toolbar responsive>
 *         <polymer-ui-icon-button icon="add"></polymer-ui-icon-button>
 *         <polymer-ui-icon-button icon="trash"></polymer-ui-icon-button>
 *         <polymer-ui-icon-button icon="search"></polymer-ui-icon-button>
 *       </polymer-ui-toolbar>
 *     </polymer-ui-toolbar>
 *
 * @class polymer-ui-toolbar
 */
-->





<polymer-element name="polymer-ui-toolbar" extends="polymer-ui-theme-aware" attributes="responsiveWidth" assetpath="../polymer-ui-toolbar/">
  <template>
    <style>/*
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
*/

:host {
  /* technical */
  display: block;
  box-sizing: border-box;
  -moz-box-sizing: border-box;
  /* border/shadow */
	border-bottom: 1px solid rgba(0, 0, 0, 0.15);
	/* size */
  height: 60px;
  font-size: 21px;
	font-family: 'Helvetica Neue Medium', 'HelveticaNeue-Medium', Helvetica, sans-serif;
	position: relative;
}

:host(.polymer-ui-light-theme:host) {
  background: #f2f2f2 -webkit-linear-gradient(top, rgba(197,197,197,0), rgba(197,197,197,0.15));
  background: #f2f2f2 -moz-linear-gradient(top, rgba(197,197,197,0), rgba(197,197,197,0.15));
  background: #f2f2f2 -ms-linear-gradient(top, rgba(197,197,197,0), rgba(197,197,197,0.15));
  color: #333333;
}

:host(.polymer-ui-dark-theme:host) {
  background: #444444 none;
  color: #f3f3f3;
}
  
:host(.narrow-layout[responsive]:host) {
  position: fixed;
  right: 0;
  bottom: 0;
  left: 0;
  z-index: 1;
  border: 0;
  border-top: 1px solid rgba(0, 0, 0, 0.28);
}

/* TODO(sorvell): use of !important due to inability to 
  naturally win over an :host style */
/*@polyfill :host > polymer-ui-icon-button */
::content > polymer-ui-icon-button {
  margin: 0px 8px 0 8px !important;
}

/*@polyfill :host > polymer-ui-menu-button */
::content > polymer-ui-menu-button {
  margin: 0px 8px 0 8px !important;
}

/*@polyfill :host > polymer-ui-toolbar */
::content > polymer-ui-toolbar {
  margin: 0;
}

/*@polyfill :host > polymer-ui-toolbar:not(.narrow-layout) */
::content > polymer-ui-toolbar:not(.narrow-layout) {
  border: 0;
  background: transparent none;
}
</style>
    <polymer-flex-layout align="center"></polymer-flex-layout>
    <polymer-media-query query="max-width: {{responsiveWidth}}" querymatches="{{queryMatches}}"></polymer-media-query>
    <content></content>
  </template>
  <script>
    Polymer('polymer-ui-toolbar', {
      responsiveWidth: '800px',
      queryMatches: false,
      defaultTheme: 'polymer-ui-light-theme',
      queryMatchesChanged: function() {
        this.classList.toggle('narrow-layout', this.queryMatches);
      }
    });
  </script>
</polymer-element>

<!--
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
-->
<!--
/**
 * @module Polymer UI Elements
 */
/**
 * polymer-ui-icon-button enables you to place an image centered in a button.
 *
 * Example:
 *
 *     <polymer-ui-icon-button src="star.png"></polymer-ui-icon-button>
 *
 * Polymer includes an icon set.  The property "icon" can be used
 * to specify which icon to use.
 *
 * Example:
 *
 *     <polymer-ui-icon-button icon="menu"></polymer-ui-icon-button>
 *
 * @class polymer-ui-icon-button
 */
-->



<polymer-element name="polymer-ui-icon-button" extends="polymer-ui-theme-aware" attributes="src index icon active" assetpath="../polymer-ui-icon-button/">
  <template>
    <style>/*
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
*/
:host {
  display: inline-block;
  box-sizing: border-box;
  -moz-box-sizing: border-box;
  width: 38px;
  height: 38px;
  background-image: none;
  border-radius: 2px;
  padding: 7px;
  margin: 2px;
  vertical-align: middle;
  cursor: pointer;
}
  
:host(.outline:host) {
  box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.1);
}

:host(:hover:host) {
  box-shadow: 0 1px 0 0 rgba(0, 0, 0, 0.12), 0 0 0 1px rgba(0, 0, 0, 0.1);
}

:host(.selected:host) {
  background-color: rgba(0, 0, 0, 0.05);
  box-shadow: inset 0 1px 0 0 rgba(0, 0, 0, 0.05), 0 0 0 1px rgba(0, 0, 0, 0.12);
}

:host(:active:host, .selected:active:host) {
  background-color: rgba(0, 0, 0, 0.05);
  box-shadow: inset 0 1px 0 0 rgba(0, 0, 0, 0.1), 0 0 0 1px rgba(0, 0, 0, 0.12);
}
  
:host(.polymer-ui-dark-theme.outline:host) {
  background-color: rgba(200, 200, 200, 0.05);
  box-shadow: 0 0 0 1px rgba(200, 200, 200, 0.1);
}

:host(.polymer-ui-dark-theme:hover:host) {
  background-color: rgba(200, 200, 200, 0.05);
  box-shadow: 0 1px 0 0 rgba(200, 200, 200, 0.12), 0 0 0 1px rgba(200, 200, 200, 0.1);
}

:host(.polymer-ui-dark-theme.selected:host) {
  background-color: rgba(220, 220, 220, 0.05);
  box-shadow: inset 0 1px 0 0 rgba(200, 200, 200, 0.05), 0 0 0 1px rgba(200, 200, 200, 0.12);
}

:host(.polymer-ui-dark-theme:active:host, .polymer-ui-dark-theme.selected:active:host) {
  background-color: rgba(200, 200, 200, 0.05);
  box-shadow: inset 0 1px 0 0 rgba(200, 200, 200, 0.1), 0 0 0 1px rgba(200, 200, 200, 0.12);
}

polymer-ui-icon {
  display: block !important;
}</style>
    <polymer-ui-icon src="{{src}}" index="{{index}}" icon="{{icon}}"><content></content></polymer-ui-icon>
  </template>
  <script>
    Polymer('polymer-ui-icon-button', {
      /**
       * The URL of an image for the icon.
       *
       * @attribute src
       * @type string
       * @default ''
       */
      src: '',
      /**
       * If true, border is placed around the button to indicate
       * active state.
       *
       * @attribute active
       * @type boolean
       * @default false
       */
      active: false,
      /**
       * Specifies the icon from the Polymer icon set.
       *
       * @attribute icon
       * @type string
       * @default ''
       */
      icon: '',
      /**
       * If a theme is applied that includes an icon set, the index of the 
       * icon to display.
       *
       * @attribute index
       * @type number
       * @default -1
       */     
      index: -1,
      activeChanged: function() {
        // TODO(sjmiles): sugar this common case
        this.classList.toggle('selected', this.active);
      }
    });
  </script>
</polymer-element>

<!--
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
-->

<script src="../marked-js/marked.min.js"></script>

<polymer-element name="marked-js" attributes="text" assetpath="../marked-js/">
  <script>
    Polymer('marked-js', {
      text: '',
      allowAuthorStyles: true,
      enteredView: function() {

        marked.setOptions({
          highlight: this.highlight.bind(this)
        });
        if (!this.text) {
          this.text = this.innerHTML;
        }
      },
      textChanged: function () {
        this.innerHTML = marked(this.text.replace(/^[^\S\n]+/gm,''));
      },
      highlight: function(code, lang) {
        return this.fire('marked-js-highlight', {code: code, lang: lang}).code || code;
      }
    });
  </script>
</polymer-element>


<script src="../polymer-doc-viewer/highlight.js/highlight.pack.js"></script>

















<polymer-element name="polymer-doc-viewer" attributes="url" assetpath="../polymer-doc-viewer/">
  <template>
    <style>/*

Original style from softwaremaniacs.org (c) Ivan Sagalaev <maniac@softwaremaniacs.org>

*/

pre code {
  display: block; padding: 0.5em;
  background: #F0F0F0;
}

pre code,
pre .subst,
pre .tag .title,
pre .lisp .title,
pre .clojure .built_in,
pre .nginx .title {
  color: black;
}

pre .string,
pre .title,
pre .constant,
pre .parent,
pre .tag .value,
pre .rules .value,
pre .rules .value .number,
pre .preprocessor,
pre .ruby .symbol,
pre .ruby .symbol .string,
pre .aggregate,
pre .template_tag,
pre .django .variable,
pre .smalltalk .class,
pre .addition,
pre .flow,
pre .stream,
pre .bash .variable,
pre .apache .tag,
pre .apache .cbracket,
pre .tex .command,
pre .tex .special,
pre .erlang_repl .function_or_atom,
pre .markdown .header {
  color: #800;
}

pre .comment,
pre .annotation,
pre .template_comment,
pre .diff .header,
pre .chunk,
pre .markdown .blockquote {
  color: #888;
}

pre .number,
pre .date,
pre .regexp,
pre .literal,
pre .smalltalk .symbol,
pre .smalltalk .char,
pre .go .constant,
pre .change,
pre .markdown .bullet,
pre .markdown .link_url {
  color: #080;
}

pre .label,
pre .javadoc,
pre .ruby .string,
pre .decorator,
pre .filter .argument,
pre .localvars,
pre .array,
pre .attr_selector,
pre .important,
pre .pseudo,
pre .pi,
pre .doctype,
pre .deletion,
pre .envvar,
pre .shebang,
pre .apache .sqbracket,
pre .nginx .built_in,
pre .tex .formula,
pre .erlang_repl .reserved,
pre .prompt,
pre .markdown .link_label,
pre .vhdl .attribute,
pre .clojure .attribute,
pre .coffeescript .property {
  color: #88F
}

pre .keyword,
pre .id,
pre .phpdoc,
pre .title,
pre .built_in,
pre .aggregate,
pre .css .tag,
pre .javadoctag,
pre .phpdoc,
pre .yardoctag,
pre .smalltalk .class,
pre .winutils,
pre .bash .variable,
pre .apache .tag,
pre .go .typename,
pre .tex .command,
pre .markdown .strong,
pre .request,
pre .status {
  font-weight: bold;
}

pre .markdown .emphasis {
  font-style: italic;
}

pre .nginx .built_in {
  font-weight: normal;
}

pre .coffeescript .javascript,
pre .javascript .xml,
pre .tex .formula,
pre .xml .javascript,
pre .xml .vbscript,
pre .xml .css,
pre .xml .cdata {
  opacity: 0.5;
}
</maniac@softwaremaniacs.org></style>
    <style>:host {
  display: block;
  /*height: 100%;*/
}

.element {
  font-size: 21px;
}

.name {
  /* typography */
  color: white;
  /* font-size: 14px; */
  font-size: 12px;
  font-weight: bold;
  text-decoration: none;
  /* colors / effects */
  background-color: #999;
  box-shadow: 0 1px 2px 0px rgba(0, 0, 0, 0.1);
  box-shadow: 0 0 1px 0 rgba(0, 0, 0, 0.1);
  border-radius: 2px;
  cursor: pointer;
  /* metrics */
  display: inline-block;
  padding: 4px 12px 5px 12px;
  margin: 4px 0;
  /*padding: 0.35em 1em;
  margin: 0.3em 0;*/
}

.method {
  background-color: #0F9D58;
}

.event {
  background-color: #F4B400;
}

.nattribute {
  background-color: #4285F4;
  border-radius: 2px 0 0 2px;
}

.type {
  background-color: white;
  border: 1px solid #4285F4;
  color: #4285F4;
  font-weight: bold;
  border-radius: 0 2px 2px 0;
  padding-top: 3px;
  padding-bottom: 4px;
}

.header {
  border: 1px solid rgba(0, 0, 0, 0.1);
  border-left: none;
  border-right: none;
  padding: 0 16px;
  line-height: 75px;
}

.ntitle {
  font-size: 13px;
  font-weight: bold;
  margin: 8px 0;
}

.box {
  margin-bottom: 40px;
}

pre code {
  font-size: 14px;
  padding: 12px 13px;
  max-width: 800px;
  white-space: pre-wrap;
  overflow: hidden;
}

a {
  color: #666;
  text-decoration: none;
}

.summary {
  width: 240px; 
  padding: 16px;
}

@media (max-width: 900px) {
  .summary {
    display: none;
  }
}

#menu {
  width: 280px;
}

#docs {
  overflow-x: auto;
  background-color: white;
}

#docsInner {
  overflow: auto;
  min-width: 500px;
}

#fixed {
  position: fixed;
  opacity: 0.95;
  right: 24px;
  left: 296px;
  background-color: white;
  z-index: 1000;
  display: none;
}

.animate {
  -webkit-transition-property: left, top, width, height;
  -webkit-transition-duration: 0.3s;
  -webkit-transition-timing-function: ease-out;
}
</style>

    <polymer-ajax url="{{url}}" response="{{data}}" handleas="json" auto=""></polymer-ajax>
    <polymer-grid-layout id="grid" on-polymer-grid-layout="{{gridLayout}}"></polymer-grid-layout>

    <div id="navigation" offscreen="basement" style="overflow-y: scroll;">
      <polymer-ui-menu selected="0" id="menu">
        <template repeat="{{classes}}">
          <polymer-ui-menu-item><a href="#{{name}}">{{name}}</a></polymer-ui-menu-item>
        </template>
      </polymer-ui-menu>
    </div>

    <div id="docs" flex="" on-marked-js-highlight="{{hilight}}">
      <div id="docsInner" flex="">
        <div id="fixed">
          <div class="header">
            <polymer-ui-icon-button icon="menu" on-tap="{{toggleNav}}" active="{{navOpen}}"></polymer-ui-icon-button>
            &nbsp;<span id="fixedTopic" class="element"></span>
          </div>
        </div>

        <template repeat="{{class in classes}}">
          <a id="{{class.name}}" class="element"></a>
          <div class="header topic">
            <polymer-ui-icon-button on-tap="{{toggleLayout}}" icon="menu" style="visibility: hidden;"></polymer-ui-icon-button>
            &nbsp;<span class="element">{{class.name}}</span>
          </div>
  
          <div>
            <polymer-flex-layout></polymer-flex-layout>

            <div class="summary">
              <section class="box">
                <div class="ntitle">Methods</div>
                <template repeat="{{class.methods}}">
                  <span class="name method">{{name}}</span><br>
                </template>
              </section>
                <section class="box">
                <div class="ntitle">Attributes</div>
                <template repeat="{{class.attributes}}">
                  <span class="name nattribute">{{name}}</span><br>
                </template>
              </section>
              <section class="box">
                <div class="ntitle">Events</div>
                <template repeat="{{class.events}}">
                  <span class="name event">{{name}}</span><br>
                </template>
              </section>
            </div>

            <div flex="">
              <div style="padding: 16px;">
                <section class="box">
                  Module<br>
                  <span class="name">{{class.module}}</span>
                </section>

                <section class="box">
                  <div class="ntitle">Description</div>
                  <marked-js>{{class.description}}</marked-js>
                </section>

                <section class="box">
                  <div class="ntitle">Methods</div>
                  <template repeat="{{class.methods}}">
                    <span class="name method">{{name}}</span>
                    <marked-js>{{description}}</marked-js>
                  </template>
                </section>

                <section class="box">
                  <div class="ntitle">Attributes</div>
                  <template repeat="{{class.attributes}}">
                    <span class="name nattribute">{{name}}</span><span class="name type">{{type}}</span>
                    <marked-js>{{description}}</marked-js>
                    <br>
                  </template>
                </section>

                <section class="box">
                  <div class="ntitle">Events</div>
                  <template repeat="{{class.events}}">
                    <span class="name event">{{name}}</span>
                    <marked-js>{{description}}</marked-js>
                    <br>
                  </template>
                </section>
              </div>
            </div>
          </div>
        </template>

        <hr>
        <div style="height: 512px"></div>
      </div>
    </div>
  </template>
  <script>
    Polymer('polymer-doc-viewer', {
      data: null,
      route: '',
      layouts: {
        open: [
          [1, 2, 2]
        ],
        closed: [
          [2, 2]
        ],
      },
      navOpen: true,
      ready: function() {
        window.addEventListener('hashchange', this.parseLocationHash.bind(this));
        // TODO(sjmiles): manual because flatiron-director didn't work, find out why
        this.parseLocationHash();
        // TODO(sjmiles): improve method of configuring grid
        this.$.grid.nodes = [this.$.navigation, this.$.docs];
        this.$.grid.layout = this.layouts.open;
        // TODO(sjmiles): make onscroll listenable via on-scroll
        this.$.docs.onscroll = this.docsScroll.bind(this);
      },
      onMutation: function(node, listener) {
        var observer = new MutationObserver(function() {
          listener.call(this, observer);
          observer.disconnect();
        }.bind(this));
        observer.observe(node, {childList: true, subtree: true});
      },
      parseLocationHash: function() {
        this.route = window.location.hash.slice(1);
      },
      gridLayout: function() {
        // TODO(sjmiles): the 'fixed' header bar is relative to the screen
        // to position it dynamically we need to know offsetLeft of the
        // docs panel after the first layout.
        if (!this.fixedLeft) {
          this.fixedLeft = this.$.docs.offsetLeft;
          this.$.fixed.style.display = 'block';
          this.effectLayout();
        }
        this.$.docs.classList.add('animate');
        this.$.fixed.classList.add('animate');
      },
      hilight: function(event, detail, sender) {
        //console.log('highlight', event.target, sender);
        detail.code = hljs.highlightAuto(detail.code).value;
      },
      docsNodeChanged: function(observer) {
        // initialize scrolling side-effects
        this.docsScroll();
        //console.log('docsNodeChanged');
      },
      docsScroll: function() {
        var t = this.$.docs.scrollTop + 80;
        var hcs = this.$.docsInner.querySelectorAll('.topic');
        for (var i = 0, hc; hc = hcs[i]; i++) {
          if (t >= hc.offsetTop && (!hcs[i+1] || t < hcs[i+1].offsetTop)) {
            var h = hc.querySelector('.element');
            if (h) {
              this.$.fixedTopic.innerText = h.innerText;	
            }
            return;
          }
        }
      },
      routeChanged: function() {
        var anchor = this.shadowRoot.querySelector('a[id="' + this.route + '"]');
        if (anchor) {
          anchor.scrollIntoView();
        }
      },
      toggleNav: function(event, detail, sender) {
        // TODO(sjmiles): would be nice to automate this common action
        this.navOpen = !this.navOpen;
      },
      navOpenChanged: function() {
        // TODO(sjmiles): would be nice to automate this common action
        this.effectLayout();
      },
      effectLayout: function() {
        this.$.grid.layout = this.navOpen ? this.layouts.open : this.layouts.closed;
        this.$.fixed.style.left = this.navOpen ? this.fixedLeft + 'px' : '0px';
        // ensure transitions start at the same time (still async)
        Platform.flush();
      },
      dataChanged: function() {
        // schedule more work when changes here propagate to DOM
        this.onMutation(this.$.docs, this.docsNodeChanged);
        // collate raw data for display
        // construct an array from modules map
        this.modules = mapdex(this.data.modules);
        // construct an array from classes map
        this.classes = mapdex(this.data.classes);
        // sort class array by name (case insensitive)
        this.classes.sort(function (a,b) {
          var an = a.name.toLowerCase(), bn = b.name.toLowerCase();
          return (an < bn) ? -1	: (an > bn) ? 1	: 0;
        });
        // construct an index of classes by module
        this.modules.forEach(function(m) {
          m.classNames = Object.keys(m.classes);
        });
        // collate classitems by class
        collate(this.data.classitems, function(item) {
          return this.data.classes[item.class];
        }.bind(this), function() {
          return 'items';
        });
        // collate class.items by itemtype
        this.classes.forEach(function(c) {
          var itemtype = '';
          if (c.items) {
            collate(c.items, function(item) {
              itemtype = item.itemtype + 's';
              return item.itemtype ? c : null;
            }, function() {
              return itemtype;
            });
          }
        });
        // filters
        function mapdex(map) {
          var a = [];
          for (var n in map) {
            a.push(map[n]);
          }
          return a;
        };
        function collate(list, getCrossIndex, getCollation) {
          list.forEach(function(item) {
            var r = getCrossIndex(item);
            if (r) {
              var c = getCollation(r);
              (r[c] || (r[c] = [])).push(item);
            }
          });
        };
      }
    });
  </script>
</polymer-element>
<polymer-element name="polymer-home-page">
  <template>
    <link rel="stylesheet" href="polymer-home-page.css">
    <h2>{{moduleName}}</h2>
    <a class="choiceC" target="_blank" href="../{{moduleName}}/smoke.html">demo</a>
    <a class="choiceB" target="_blank" href="../../designer/?element={{moduleName}}">sandbox</a>
    <a class="choiceD" target="_blank" href="fail.html">install</a>
    <polymer-doc-viewer url="docs.json"></polymer-doc-viewer>
  </template>
  <script>
    Polymer('polymer-home-page', {
      ready: function() {
        var path = location.pathname.split('/');
        var name = path.pop() || path.pop();
        if (name.indexOf('.html') >= 0) {
          name = path.pop();
        }
        document.querySelector('title').textContent = name;
        this.moduleName = name;
      }
    });
  </script>
</polymer-element>
